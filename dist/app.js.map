{"version":3,"sources":["src/index.ts","../v2-account-migrator/src/index.ts","../v2-account-migrator/src/events.ts","../v2-account-migrator/ts-client-library/packages/util/src/hex.ts","../v2-account-migrator/opaque/src/account.ts","../v2-account-migrator/ts-client-library/packages/account-management/src/index.ts","../v2-account-migrator/ts-client-library/packages/account-system/src/index.ts","../v2-account-migrator/ts-client-library/packages/filesystem-access/src/filesystem-object.ts","../v2-account-migrator/ts-client-library/packages/middleware-web/src/index.ts","../v2-account-migrator/ts-client-library/packages/util/src/promise.ts","../v2-account-migrator/ts-client-library/packages/util/src/payload.ts","../v2-account-migrator/ts-client-library/packages/util/src/b64.ts","../v2-account-migrator/ts-client-library/packages/account-system/src/AccountSystem.ts","../v2-account-migrator/ts-client-library/packages/account-system/src/MetadataAccess.ts","../v2-account-migrator/opaque/src/utils/hashToPath.ts","../v2-account-migrator/opaque/src/core/account/api/v1/index.ts","../v2-account-migrator/ts-client-library/packages/middleware-web/src/webAccountMiddleware.ts","../v2-account-migrator/ts-client-library/packages/middleware-web/src/webNetworkMiddleware.ts","../v2-account-migrator/ts-client-library/packages/filesystem-access/src/events.ts","../v2-account-migrator/ts-client-library/packages/util/src/serializeEncrypted.ts","../v2-account-migrator/ts-client-library/packages/util/src/arrayEquality.ts","../v2-account-migrator/ts-client-library/packages/util/src/path.ts","../v2-account-migrator/ts-client-library/packages/util/src/mnemonic.ts","../v2-account-migrator/ts-client-library/packages/util/src/arrayMerge.ts","../v2-account-migrator/ts-client-library/packages/account-system/src/dag.ts","../v2-account-migrator/ts-client-library/packages/util/src/uint.ts","../v2-account-migrator/opaque/src/core/account/api/v0/downloadFile.ts","../v2-account-migrator/opaque/src/core/account/api/v0/generateSubHDKey.ts","../v2-account-migrator/opaque/src/core/account/api/v0/getAccountInfo.ts","../v2-account-migrator/opaque/src/core/account/api/v0/getFolderHDKey.ts","../v2-account-migrator/opaque/src/core/account/api/v0/getFolderLocation.ts","../v2-account-migrator/opaque/src/core/account/api/v0/getHandle.ts","../v2-account-migrator/opaque/src/core/account/api/v0/isPaid.ts","../v2-account-migrator/opaque/src/core/account/api/v0/register.ts","../v2-account-migrator/opaque/src/core/account/api/v1/buildFullTree.ts","../v2-account-migrator/opaque/src/core/account/api/v1/createFolder.ts","../v2-account-migrator/opaque/src/core/account/api/v1/createFolderMeta.ts","../v2-account-migrator/opaque/src/core/account/api/v1/createMetaQueue.ts","../v2-account-migrator/opaque/src/core/account/api/v1/deleteFile.ts","../v2-account-migrator/opaque/src/core/account/api/v1/deleteFolder.ts","../v2-account-migrator/opaque/src/core/account/api/v1/deleteFolderMeta.ts","../v2-account-migrator/opaque/src/core/account/api/v1/deleteVersion.ts","../v2-account-migrator/opaque/src/core/account/api/v1/getFolderMeta.ts","../v2-account-migrator/opaque/src/core/account/api/v1/isExpired.ts","../v2-account-migrator/opaque/src/core/account/api/v1/login.ts","../v2-account-migrator/opaque/src/core/account/api/v1/moveFile.ts","../v2-account-migrator/opaque/src/core/account/api/v1/moveFolder.ts","../v2-account-migrator/opaque/src/core/account/api/v1/renameFile.ts","../v2-account-migrator/opaque/src/core/account/api/v1/renameFolder.ts","../v2-account-migrator/opaque/src/core/account/api/v1/renewAccount.ts","../v2-account-migrator/opaque/src/core/account/api/v1/setFolderMeta.ts","../v2-account-migrator/opaque/src/core/account/api/v1/upgradeAccount.ts","../v2-account-migrator/opaque/src/core/account/api/v1/uploadFile.ts","../v2-account-migrator/ts-client-library/packages/util/src/derive.ts","../v2-account-migrator/opaque/src/download.ts","../v2-account-migrator/opaque/src/core/hashing.ts","../v2-account-migrator/opaque/src/core/requests/checkPaymentStatus.ts","../v2-account-migrator/opaque/src/utils/cleanPath.ts","../v2-account-migrator/opaque/src/core/requests/createAccount.ts","../v2-account-migrator/opaque/src/utils/netQueue.ts","../v2-account-migrator/opaque/src/core/account/api/v1/meta/removeFile.ts","../v2-account-migrator/opaque/src/core/account/api/v1/meta/removeVersion.ts","../v2-account-migrator/opaque/src/core/account/api/v1/meta/addFile.ts","../v2-account-migrator/opaque/src/core/account/api/v1/meta/addFolder.ts","../v2-account-migrator/opaque/src/core/account/api/v1/meta/removeFolder.ts","../v2-account-migrator/opaque/src/core/requests/metadata.ts","../v2-account-migrator/opaque/src/core/requests/deleteFile.ts","../v2-account-migrator/opaque/src/core/encryption.ts","../v2-account-migrator/opaque/src/core/account/folder-meta.ts","../v2-account-migrator/opaque/src/core/account/api/v0/index.ts","../v2-account-migrator/opaque/src/core/account/file-entry.ts","../v2-account-migrator/opaque/src/core/account/folder-entry.ts","../v2-account-migrator/opaque/src/core/requests/upgradeAccount.ts","../v2-account-migrator/opaque/src/core/requests/renewAccount.ts","../v2-account-migrator/opaque/src/upload.ts","../v2-account-migrator/opaque/src/core/account/file-version.ts","../v2-account-migrator/opaque/src/core/metadata.ts","../v2-account-migrator/opaque/src/core/helpers.ts","../v2-account-migrator/opaque/src/streams/decryptStream.ts","../v2-account-migrator/opaque/src/streams/downloadStream.ts","../v2-account-migrator/opaque/src/core/request.ts","../v2-account-migrator/opaque/src/core/constants.ts","../v2-account-migrator/opaque/src/core/account/api/v0/getFolderMeta.ts","../v2-account-migrator/opaque/src/streams/encryptStream.ts","../v2-account-migrator/opaque/src/streams/uploadStream.ts","../v2-account-migrator/opaque/src/streams/fileSourceStream.ts","../v2-account-migrator/opaque/src/streams/bufferSourceStream.ts","../v2-account-migrator/opaque/src/core/requests/getPlans.ts"],"names":["formEl","document","body","appendChild","createElement","labelEl","labelTextEl","textContent","inputEl","submitEl","type","addEventListener","e","preventDefault","disabled","accountHandle","hex_1","value","length","runMigrator","containerEl","statusEl","detailsEl","migrator","v2_account_migrator_1","storageNodeV1","storageNodeV2","events_1","STATUS","s","console","log","detail","status","DETAILS","d","info","details","WARNING","w","warn","warning","migrate","EventTarget","_status","_details","constructor","handle","config","mh","account_1","downloadOpts","endpoint","uploadOpts","cryptoMiddleware","middleware_web_1","asymmetricKey","netMiddleware","metadataAccess","account_system_1","crypto","net","metadataNode","account","account_management_1","storageNode","accountSystem","setStatus","signUp","size","waitForPayment","setDetails","rootFolderV1","getFolderMeta","err","dispatchEvent","allFolders","collectFolderRecursively","allFiles","map","folder","files","file","flat","rootFolderV2","addFolder","path","folderMeta","fileMetadata","version","versions","slice","name","fileMetadataV2Location","getFileMetadataLocationByFileHandle","getFileMetadata","finished","finishUpload","fileHandle","fileLocation","fileEncryptionKey","fso","filesystem_object_1","location","undefined","m","exists","metadata","fileMetadataV2","addUpload","lastModified","modified","Date","now","out","output","fm","concat","f","folders","subPath","path_browserify_1","join","CustomEvent","data","MigratorEvents","b","reduce","acc","n","push","toString","h","Uint8Array","match","parseInt","mnemonic","_mnemonic","trim","split","bip39_1","Error","seed","hdkey_1d","metaQueue","metaFolderCreating","generateSubHDKey","pathString","index_1","uploadFile","dir","downloadFile","deleteFile","deleteVersion","getFolderHDKey","getFolderLocation","createFolderMeta","createFolder","deleteFolderMeta","deleteFolder","moveFile","to","moveFolder","renameFile","renameFolder","setFolderMeta","buildFullTree","getAccountInfo","isExpired","isPaid","login","register","duration","limit","upgrade","renew","Account","hashToPath_1","hash","replace","Object","assign","hdkey_1","derive","String","privateKey","Buffer","from","chainCode","payload","payload_1","res","POST","JSON","stringify","Response","json","ok","createSubscription","stripeToken","plans","GET","values","filter","plan","storageInGB","paymentStatus","invoice","AccountPaymentStatus","PAID","cost","ethAddress","durationInMonths","storageLimit","done","resolveDone","promise_1","iTime","iFn","setTimeout","renewStatus","fileIDs","metadataKeys","fileHandles","id","key","b64_1","renewAccount","opctInvoice","waitForRenewPayment","renewStatusArgs","AccountRenewStatus","upgradeStatus","upgradeAccount","waitForUpgradePayment","UpgradeStatusArgs","AccountUpgradeStatus","_handle","_location","public","private","_getDownloadURL","fileID","text","downloadURL","rs","arrayBuffer","serializeEncrypted_1","parse","TextDecoder","decode","delete","_beforeDelete","FileSystemObjectDeletionError","_afterDelete","rj","promise","Promise","resole","reject","rawPayload","payloadKey","timestamp","Math","floor","js_sha3_1","signature","sign","pubKey","getPublicKey","publicKey","extraPayload","FormData","append","keys","forEach","Blob","buffer","js_base64_1","padEnd","ceil","b64","item","min","max","recieved","illegal","action","validateFilename","AccountSystemLengthError","includes","sep","AccountSystemSanitizationError","validateDirectoryPath","unfreezeUint8Array","arr","guid","prefix","indexes","share","_m","async_mutex_1","getFileDerivePath","getFilesIndex","markCacheDirty","runExclusive","_getFilesIndex","filesIndex","get","automerge_1d","deleted","errored","_getFileMetadataLocationByFileHandle","fileEntry","find","arrayEquality_1","AccountSystemNotFoundError","getFileMetadataLocationByFileLocation","_getFileMetadataLocationByFileLocation","getFileIndexEntryByFileMetadataLocation","_getFileIndexEntryByFileMetadataLocation","_getFileMetadata","filePath","doc","folderDerive","uploaded","shortLinks","filename","meta","pub","_addUpload","path_1","_addFolder","metaLocation","getRandomValues","arrayMerge_1","change","_finishUpload","fileMeta","getFolderDerivePath","newName","_renameFile","fileIndexEntry","newPath","_moveFile","oldFileMeta","newFolder","fileEntryIndex","findIndex","splice","newFileMeta","removeFile","_removeFile","fileIndex","getFoldersIndex","_getFoldersIndex","foldersIndex","duplicates","Set","p","i","indexOf","dup","getFolderIndexEntryByPath","_getFolderIndexEntryByPath","folderEntry","getFoldersInFolderByPath","_getFoldersInFolderByPath","getAllFoldersInFolderRecursivelyByPath","_getAllFoldersInFolderRecursivelyByPath","all","getAllFilesInFolderRecursivelyByPath","_getAllFilesInFolderRecursivelyByPath","_getFolderMetadataByPath","foldersInFolder","filesInFolder","some","folderFileEntry","getFoldersInFolderByLocation","_getFoldersInFolderByLocation","getAllFoldersInFolderRecursivelyByLocation","_getAllFoldersInFolderRecursivelyByLocation","getAllFilesInFolderRecursivelyByLocation","_getAllFilesInFolderRecursivelyByLocation","_getFolderMetadataByLocation","getFolderMetadataByPath","getFolderMetadataByLocation","folderPath","dirname","foldersIndexDoc","entry","basename","_renameFolder","_moveFolder","oldPath","op","catch","AccountSystemAlreadyExistsError","subs","relative","rel","removeFolderByPath","_removeFolderByPath","_removeFolderByLocation","removeFolderByLocation","AccountSystemNotEmptyError","childFolders","folderIndex","getShareHandle","Array","locationKey","encryptionKey","getShareIndex","_getShareIndex","sharedIndex","shared","shareEntry","fileLocations","l","getSharesByHandle","_getSharesByHandle","shareIndex","filesInit","_share","fileInit","mnemonic_1","Boolean","shareMeta","changePublic","dateShared","getShared","getPublic","sha256","digest","sha256_1d","update","getHash","packChanges","changes","len","cur","packed","lArr","uint_1","lArr2","unpackChanges","c","dags","cache","metadataIndexPath","_sem","priv","_markCacheDirty","pubString","cached","dirty","getMetadataLocationKeysList","metaIndexObject","_get","metaIndexPrivs","privs","validLocations","privString","metadataV2Key","_metadataIndexAdd","encryptKey","encryptKeyString","metaIndexPriv","_change","encryptKeys","_metadataIndexRemove","description","fn","isPublic","curDoc","init","dag_1","dag","newDoc","getChanges","encrypted","encrypt","v","addReduced","edges","parentEdges","metadataV2Edges","edge","binary","metadataV2Sig","metadataV2Vertex","lastAccess","decryptKey","logging","fromBinary","metadataV2","decrypted","nodes","decrypt","applyChanges","_getPublic","requestBody","_delete","deletePublic","hashToPath","v1","getHandle","createMetaQueue","symmetricKey","k","ReferenceError","hd","child","derive_1","sig","generateSymmetricKey","subtle","exportKey","generateKey","importKey","iv","tagLength","ct","fetchAdapter","method","address","headers","mapReturn","fetch","redirected","statusText","url","DownloadEvents","METADATA","START","FINISH","PROGRESS","UploadEvents","FileSystemObjectEvents","DELETE","bytes","a","normalize","parent","other","exports","entropy","hex","j","stack","why","checkLength","actual","BinarySerializationError","sinks","DAG","DAGBinaryTypes","nodesLength","nbin","add","DAGVertex","edgesLength","ebin","addEdge","DAGEdge","node","clone","VertexExistsError","sink","EdgeExistsError","dependencies","pop","sinkIndex","depth","parents","sort","apply","seen","CyclicReferenceError","newSeen","hashes","DAGDigestTypes","BRANCH","VertexNotFoundError","leaf","LEAF","branches","EDGE","VERTEX","dataLength","random","offset","masterHandle","download_1d","hashing_1","checkPaymentStatus_1","cleanPath_1","generateSubHDKey_1","accountInfoResponse","createAccountResponse","createAccount_1","resolve","interval","setInterval","time","clearInterval","tree","getFolderMeta_1","createFolderFn","fullDir","folder_meta_1","createMetaQueue_1","folder_entry_1","metadata_1","error","netQueue_1","setFolderMeta_1","types","addFolder_1","addFile_1","removeFolder_1","removeFile_1","removeVersion_1","addType","handler","existingFile","deleteVersion_1","deleteFile_1","folderKey","response","metaString","encryption_1","node_forge_1","ByteBuffer","unminify","toMeta","oldDir","newDir","outerMeta","existingFolder","createFolderMeta_1","deleteFolderMeta_1","file_entry_1","createFolder_1","buildFullTree_1","getFolderLocation_1","renewAccountInvoiceResponse","renewAccount_1","renewAccountStatusOpts","renewAccountStatusResponse","minify","encryptedMeta","toHex","upgradeAccountInvoiceResponse","upgradeAccount_1","upgradeAccountStatusOpts","upgradeAccountStatusResponse","upload","upload_1d","ee","on","progress","emit","finishedUpload","file_version_1","once","labels","labelSha","Uint16Array","byteOffset","byteLength","BYTES_PER_ELEMENT","reverse","METADATA_PATH","DEFAULT_OPTIONS","freeze","autoStart","opts","_metadata","downloadMetadata","toBuffer","chunks","totalLength","startDownload","decryptStream","toFile","File","helpers_1","getDownloadURL","propagateError","overwrite","req","downloadURLRequest","axios_1d","post","options","fileDownloadUrl","metadataRequest","responseType","isDownloading","downloadStream","downloadStream_1d","decryptStream_1d","target","pipe","finishDownload","message","process","nextTick","val","web3_utils_1","hdNode","signedPayload","request_1","posixSep","RegExp","posixSepEnd","win32Sep","trimTrailingSep","cleanPath","metadataKey","timeout","updating","queue","_process","debounce_1d","queueCopy","result","_fetch","shift","_update","_timeout","removeVersion","addFile","removeFolder","Forge","cipher","md","util","byteBuffer","keyBuf","getBytesSync","constants_1","createCipher","start","finish","clear","putBuffer","mode","tag","putBytes","string","encoding","buf","createBuffer","read","getBytes","decipher","createDecipher","truncate","raw","created","MinifiedFolderMeta","FolderMeta","v0","MinifiedFileEntryMeta","FileEntryMeta","MinifiedFolderEntryMeta","FolderEntryMeta","PART_MIN_SIZE","POLYFILL_FORMDATA","DEFAULT_FILE_PARAMS","blockSize","startUpload","uploadMetadata","params","fileSizeInByte","uploadSize","endIndex","getHeaders","readStream","reader","encryptStream","encryptStream_1d","uploadStream","uploadStream_1d","MinifiedFileVersion","FileVersion","PROTOCOL_VERSION","byteStr","encode","create","bytesToHex","substring","end","nameFallback","is_buffer_1d","bufferSourceStream_1d","lite_1d","getType","fileSourceStream_1d","blockCount","partSize","chunkSize","chunkCount","chunksPerPart","binaryMode","objectMode","readable_stream_1","iter","_transform","chunk","callback","autostart","maxParallelDownloads","maxRetries","chunkId","pushId","bytesDownloaded","isDownloadFinished","ongoingDownloads","pushChunk","_download","_read","attemptDownload","_pushChunk","chunkIndex","index","range","download","_afterDownload","keccak256","form_data_1d","pl","contentType","knownLength","PART_MIME","maxParallelUploads","bytesUploaded","blockBuffer","partBuffer","bufferSize","ongoingUploads","retries","partIndex","finalCallback","_write","_addPart","_attemptUpload","_final","blocks","block","set","part","_upload","cork","chunkData","onUploadProgress","event","then","_afterUpload","_uploadError","uncork","confirmUpload","_confirmUpload","bind","uploadFinished","missingIndexes","blob","FileReader","_onChunkRead","readyState","LOADING","_readChunkFromBlob","onload","readAsArrayBuffer","_readChunkFromBuffer"],"mappings":"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","file":"","sourcesContent":["import { AccountMigrator } from \"v2-account-migrator\"\nimport { MigratorEvents } from \"v2-account-migrator/src/events\"\nimport { hexToBytes } from \"v2-account-migrator/ts-client-library/packages/util/src/hex\"\n\nconst formEl = document.body.appendChild(document.createElement(\"form\"))\nconst labelEl = formEl.appendChild(document.createElement(\"label\"))\nconst labelTextEl = labelEl.appendChild(document.createElement(\"span\"))\nlabelTextEl.textContent = \"Account Handle\"\nconst inputEl = labelEl.appendChild(document.createElement(\"input\"))\nconst submitEl = formEl.appendChild(document.createElement(\"button\"))\nsubmitEl.textContent = \"Migrate\"\nsubmitEl.type = \"submit\"\n\nformEl.addEventListener(\"submit\", (e) => {\n\te.preventDefault()\n\n\tinputEl.disabled = true\n\tsubmitEl.disabled = true\n\n\tconst accountHandle = hexToBytes(inputEl.value)\n\n\tif (accountHandle.length == 64) {\n\t\trunMigrator(accountHandle)\n\t}\n})\n\nconst runMigrator = async (accountHandle: Uint8Array) => {\n\tconst containerEl = document.body.appendChild(document.createElement(\"div\"))\n\tconst statusEl = containerEl.appendChild(document.createElement(\"h1\"))\n\tconst detailsEl = containerEl.appendChild(document.createElement(\"h2\"))\n\n\tconst migrator = new AccountMigrator(\n\t\taccountHandle,\n\t\t{\n\t\t\tstorageNodeV1: \"https://broker-1.opacitynodes.com:3000\",\n\t\t\tstorageNodeV2: \"https://beta-broker.opacitynodes.com:3000\",\n\t\t}\n\t)\n\n\tmigrator.addEventListener(MigratorEvents.STATUS, (s: any) => {\n\t\tconsole.log(\"Status:\", s.detail.status)\n\t\tstatusEl.textContent = s.detail.status\n\t})\n\n\tmigrator.addEventListener(MigratorEvents.DETAILS, (d: any) => {\n\t\tconsole.info(\"Details:\", d.detail.details)\n\t\tdetailsEl.textContent = d.detail.details\n\t})\n\n\tmigrator.addEventListener(MigratorEvents.WARNING, (w: any) => {\n\t\tconsole.warn(\"Warning:\", w.detail.warning)\n\t})\n\n\tawait migrator.migrate()\n}\n","import { posix } from \"path-browserify\"\n\nimport { MigratorStatusEvent, MigratorDetailsEvent, MigratorWarningEvent } from \"./events\"\n\nimport { MasterHandle } from \"../opaque/src/account\"\nimport { FolderMeta } from \"../opaque/src/core/account/folder-meta\"\nimport { FileEntryMeta } from \"../opaque/src/core/account/file-entry\"\n\nimport { Account } from \"../ts-client-library/packages/account-management\"\nimport { AccountSystem, AccountSystemNotFoundError, MetadataAccess } from \"../ts-client-library/packages/account-system\"\nimport { FileSystemObject } from \"../ts-client-library/packages/filesystem-access/src/filesystem-object\"\nimport { CryptoMiddleware, NetworkMiddleware } from \"../ts-client-library/packages/middleware\"\nimport { WebAccountMiddleware, WebNetworkMiddleware } from \"../ts-client-library/packages/middleware-web\"\nimport { bytesToHex, hexToBytes } from \"../ts-client-library/packages/util/src/hex\"\n\nexport type AccountMigratorConfig = {\n\tstorageNodeV1: string\n\tstorageNodeV2: string\n}\n\nexport class AccountMigrator extends EventTarget {\n\tconfig: AccountMigratorConfig\n\n\tmh: MasterHandle\n\n\taccount: Account\n\taccountSystem: AccountSystem\n\tcryptoMiddleware: CryptoMiddleware\n\tnetMiddleware: NetworkMiddleware\n\tmetadataAccess: MetadataAccess\n\n\t_status = \"\"\n\tget status () {\n\t\treturn this._status\n\t}\n\n\t_details = \"\"\n\tget details () {\n\t\treturn this._details\n\t}\n\n\tconstructor (handle: Uint8Array, config: AccountMigratorConfig) {\n\t\tsuper()\n\n\t\tthis.config = config\n\n\t\t// v1\n\t\tthis.mh = new MasterHandle({ handle: bytesToHex(handle) }, {\n\t\t\tdownloadOpts: {\n\t\t\t\tendpoint: config.storageNodeV1,\n\t\t\t},\n\t\t\tuploadOpts: {\n\t\t\t\tendpoint: config.storageNodeV1,\n\t\t\t}\n\t\t})\n\n\t\t// v2\n\t\tthis.cryptoMiddleware = new WebAccountMiddleware({\n\t\t\tasymmetricKey: handle\n\t\t})\n\t\tthis.netMiddleware = new WebNetworkMiddleware()\n\t\tthis.metadataAccess = new MetadataAccess({\n\t\t\tcrypto: this.cryptoMiddleware,\n\t\t\tnet: this.netMiddleware,\n\t\t\tmetadataNode: config.storageNodeV2,\n\t\t})\n\t\tthis.account = new Account({\n\t\t\tcrypto: this.cryptoMiddleware,\n\t\t\tnet: this.netMiddleware,\n\t\t\tstorageNode: this.config.storageNodeV2,\n\t\t})\n\t\tthis.accountSystem = new AccountSystem({\n\t\t\tmetadataAccess: this.metadataAccess\n\t\t})\n\t}\n\n\tasync migrate () {\n\t\t// TESTING\n\t\tthis.setStatus(\"TESTING: Signing up\")\n\t\tawait this.account.signUp({ size: 10 })\n\t\tawait this.account.waitForPayment()\n\t\t// /TESTING\n\n\t\tthis.setStatus(\"Checking if account is still on v1.\")\n\t\tthis.setDetails(\"Getting v1 root folder.\")\n\t\ttry {\n\t\t\tconst rootFolderV1 = await this.mh.getFolderMeta(\"/\")\n\t\t\tconsole.log(rootFolderV1)\n\t\t} catch (err) {\n\t\t\tthis.dispatchEvent(new MigratorWarningEvent({ warning: \"Account was already migrated, or has never been initialized.\" }))\n\n\t\t\treturn\n\t\t}\n\n\t\tthis.setDetails(\"\")\n\t\tthis.setStatus(\"Collecting all folders. This may take a while.\")\n\t\tconst allFolders = await this.collectFolderRecursively(\"/\")\n\t\tconsole.log(allFolders)\n\n\t\tthis.setDetails(\"\")\n\t\tthis.setStatus(\"Collecting all files.\")\n\t\tconst allFiles = allFolders.map((folder) => folder[1].files.map((file) => [folder[0], file] as [string, FileEntryMeta])).flat()\n\t\tconsole.log(allFiles)\n\n\t\tthis.setStatus(\"Migrating folders.\")\n\n\t\ttry {\n\t\t\tthis.setDetails(\"Initializing v2 root folder.\")\n\t\t\tconst rootFolderV2 = await this.accountSystem.addFolder(\"/\")\n\t\t\tconsole.log(rootFolderV2)\n\t\t} catch (err) {\n\t\t\tif (err) {\n\t\t\t\tthrow err\n\t\t\t}\n\t\t}\n\n\t\tfor (let [path, folderMeta] of allFolders) {\n\t\t\tthis.setDetails(`Initializing v2 folder \"${path}\".`)\n\n\t\t\ttry {\n\t\t\t\tawait this.accountSystem.addFolder(path)\n\t\t\t} catch (err) {\n\t\t\t\tthis.dispatchEvent(new MigratorWarningEvent({ warning: \"Recieved unknown error: \" + err }))\n\t\t\t}\n\t\t}\n\n\t\tthis.setStatus(\"Migrating files.\")\n\n\t\tfor (let [path, fileMetadata] of allFiles) {\n\t\t\tfor (let version of fileMetadata.versions) {\n\t\t\t\tthis.setDetails(`Initializing file ${version.handle.slice(0, 4)}... (\"${fileMetadata.name}\") in \"${path}\".`)\n\n\t\t\t\ttry {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst fileMetadataV2Location = await this.accountSystem.getFileMetadataLocationByFileHandle(hexToBytes(version.handle))\n\t\t\t\t\t\tconst fileMetadata = await this.accountSystem.getFileMetadata(fileMetadataV2Location)\n\n\t\t\t\t\t\tif (!fileMetadata.finished) {\n\t\t\t\t\t\t\tawait this.accountSystem.finishUpload(fileMetadataV2Location)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.dispatchEvent(new MigratorWarningEvent({ warning: \"File handle already exists in metadata.\" }))\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tif (err instanceof AccountSystemNotFoundError) {\n\t\t\t\t\t\t\tconst fileHandle = hexToBytes(version.handle)\n\t\t\t\t\t\t\tconst fileLocation = fileHandle.slice(0, 32)\n\t\t\t\t\t\t\tconst fileEncryptionKey = fileHandle.slice(32, 64)\n\n\t\t\t\t\t\t\tconst fso = new FileSystemObject({\n\t\t\t\t\t\t\t\thandle: fileHandle,\n\t\t\t\t\t\t\t\tlocation: undefined,\n\t\t\t\t\t\t\t\tconfig: {\n\t\t\t\t\t\t\t\t\tcrypto: this.cryptoMiddleware,\n\t\t\t\t\t\t\t\t\tnet: this.netMiddleware,\n\t\t\t\t\t\t\t\t\tstorageNode: this.config.storageNodeV2,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\tconst m = (await fso.exists()) ? await fso.metadata() : undefined\n\n\t\t\t\t\t\t\tconst fileMetadataV2 = await this.accountSystem.addUpload(\n\t\t\t\t\t\t\t\tfileLocation,\n\t\t\t\t\t\t\t\tfileEncryptionKey,\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\tfileMetadata.name,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlastModified: m?.lastModified || version.modified || fileMetadata.modified || Date.now(),\n\t\t\t\t\t\t\t\t\tsize: m?.size || version.size,\n\t\t\t\t\t\t\t\t\ttype: m?.type || \"\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tawait this.accountSystem.finishUpload(fileMetadataV2.location)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.dispatchEvent(new MigratorWarningEvent({ warning: \"Recieved unknown error: \" + err }))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.dispatchEvent(new MigratorWarningEvent({ warning: \"Recieved unknown error: \" + err }))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.setDetails(\"\")\n\t}\n\n\tprivate async collectFolderRecursively (path: string, out: [string, FolderMeta][] = []) {\n\t\tlet output = out.slice()\n\n\t\tthis.setDetails(`Getting v1 folder \"${path}\".`)\n\n\t\ttry {\n\t\t\tconst fm = await this.mh.getFolderMeta(path)\n\n\t\t\toutput = output.concat([[path, fm]])\n\n\t\t\tfor (let f of fm.folders) {\n\t\t\t\tconst subPath = posix.join(path, f.name)\n\t\t\t\toutput = output.concat(await this.collectFolderRecursively(subPath))\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthis.dispatchEvent(new MigratorWarningEvent({ warning: err }))\n\t\t} finally {\n\t\t\treturn output\n\t\t}\n\t}\n\n\tprivate setStatus (status: string) {\n\t\tthis.dispatchEvent(new MigratorStatusEvent({ status }))\n\t\tthis._status = status\n\t}\n\n\tprivate setDetails (details: string) {\n\t\tthis.dispatchEvent(new MigratorDetailsEvent({ details: details }))\n\t\tthis._details = details\n\t}\n}\n","import { EventListenerOrEventListenerObject } from \"../ts-client-library/packages/util/src/events\"\n\nexport enum MigratorEvents {\n\tSTATUS = \"status\",\n\tDETAILS = \"details\",\n\tWARNING = \"warning\",\n}\n\ntype MigratorStatusEventData = { status: string }\nexport class MigratorStatusEvent extends CustomEvent<MigratorStatusEventData> {\n\tconstructor (data: MigratorStatusEventData) {\n\t\tsuper(MigratorEvents.STATUS, { detail: data })\n\t}\n}\n\ntype MigratorDetailsEventData = { details: string }\nexport class MigratorDetailsEvent extends CustomEvent<MigratorDetailsEventData> {\n\tconstructor (data: MigratorDetailsEventData) {\n\t\tsuper(MigratorEvents.DETAILS, { detail: data })\n\t}\n}\n\ntype MigratorWarningEventData = { warning: string }\nexport class MigratorWarningEvent extends CustomEvent<MigratorWarningEventData> {\n\tconstructor (data: MigratorWarningEventData) {\n\t\tsuper(MigratorEvents.WARNING, { detail: data })\n\t}\n}\n\nexport interface IOpaqueDownloadEvents {\n\taddEventListener(\n\t\ttype: MigratorStatusEventData,\n\t\tlistener: EventListener | EventListenerObject | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n\n\taddEventListener(\n\t\ttype: MigratorEvents.STATUS,\n\t\tlistener: EventListenerOrEventListenerObject<MigratorStatusEvent> | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n\taddEventListener(\n\t\ttype: MigratorEvents.DETAILS,\n\t\tlistener: EventListenerOrEventListenerObject<MigratorDetailsEvent> | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n\taddEventListener(\n\t\ttype: MigratorEvents.WARNING,\n\t\tlistener: EventListenerOrEventListenerObject<MigratorWarningEvent> | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n}\n","export const bytesToHex = (b: Uint8Array) => {\n\treturn b\n\t\t.reduce<string[]>((acc, n) => {\n\t\t\tacc.push((\"00\" + n.toString(16)).slice(-2))\n\t\t\treturn acc\n\t\t}, [])\n\t\t.join(\"\")\n}\n\nexport const hexToBytes = (h: string) => {\n\treturn new Uint8Array((h.match(/.{1,2}/g) || []).map((b) => parseInt(b, 16)))\n}\n","import {\n  generateMnemonic,\n  mnemonicToSeedSync,\n  validateMnemonic,\n} from \"bip39\"\nimport HDKey, { fromMasterSeed } from \"hdkey\"\nimport * as namehash from \"eth-ens-namehash\"\n\nimport { hashToPath } from \"./utils/hashToPath\"\nimport { hash } from \"./core/hashing\"\n\nimport { NetQueue } from \"./utils/netQueue\"\n\nimport {\n  FolderMeta,\n  FileEntryMeta,\n  FileVersion,\n  FolderEntryMeta\n} from \"./core/account/metadata\"\n\nimport {\n  buildFullTree,\n  createFolder,\n  createFolderMeta,\n  deleteFile,\n  deleteFolder,\n  deleteFolderMeta,\n  deleteVersion,\n  downloadFile,\n  generateSubHDKey,\n  getAccountInfo,\n  getFolderHDKey,\n  getFolderLocation,\n  getFolderMeta,\n  getHandle,\n  isExpired,\n  isPaid,\n  login,\n  moveFile,\n  MoveFileArgs,\n  moveFolder,\n  MoveFolderArgs,\n  register,\n  renameFile,\n  RenameFileArgs,\n  renameFolder,\n  RenameFolderArgs,\n  renewAccount,\n  setFolderMeta,\n  uploadFile,\n  upgradeAccount\n} from \"./core/account/api/v1/index\"\n\nimport { RequireOnlyOne } from \"./types/require-only-one\"\n\n/**\n * <b><i>this should never be shared or left in storage</i></b><br />\n *\n * a class for representing the account mnemonic\n *\n * @public\n */\nclass Account {\n  private _mnemonic: string;\n\n  get mnemonic() {\n    return this._mnemonic.trim().split(/\\s+/g);\n  }\n\n  /**\n   * creates an account from a mnemonic if provided, otherwise from entropy\n   *\n   * @param mnemonic - the mnemonic to use for the account\n   */\n  constructor(mnemonic: string = generateMnemonic()) {\n    if (!validateMnemonic(mnemonic)) {\n      throw new Error(\"mnemonic provided was not valid\");\n    }\n\n    this._mnemonic = mnemonic;\n  }\n\n  get seed() {\n    return mnemonicToSeedSync(this._mnemonic);\n  }\n}\n\ntype MasterHandleCreator = RequireOnlyOne<\n  { account: Account; handle: string },\n  \"account\" | \"handle\"\n>\n\ntype MasterHandleOptions = {\n  uploadOpts?\n  downloadOpts?\n}\n\n/**\n * <b><i>this should never be shared or left in storage</i></b><br />\n *\n * a class for creating a master handle from an account mnemonic\n *\n * @remarks\n *\n * a master handle is responsible for:\n *  <br /> - logging in to an account\n *  <br /> - signing changes for the account\n *  <br /> - deterministic entropy for generating features of an account (such as folder keys)\n *\n * @public\n */\nclass MasterHandle extends HDKey {\n  uploadOpts\n  downloadOpts\n  metaQueue: {\n    [key: string]: NetQueue<FolderMeta>\n  } = {}\n  metaFolderCreating: {\n    [key: string]: boolean\n  } = {}\n\n  /**\n   * creates a master handle from an account\n   *\n   * @param _ - the account to generate the handle from\n   * @param _.account - an {@link Account}\n   * @param _.handle - an account handle as a string\n   */\n  constructor({\n    account,\n    handle,\n  }: MasterHandleCreator,\n  {\n    uploadOpts = {},\n    downloadOpts = {}\n  }: MasterHandleOptions = {}) {\n    super();\n\n    this.uploadOpts = uploadOpts\n    this.downloadOpts = downloadOpts\n\n    if (account && account.constructor == Account) {\n      const path = \"m/43'/60'/1775'/0'/\" + hashToPath(namehash.hash(\"opacity.io\").replace(/^0x/, \"\"))\n\n      // ethereum/EIPs#1775\n      Object.assign(\n        this,\n        fromMasterSeed(account.seed).derive(path)\n      );\n    } else if (handle && handle.constructor == String) {\n      this.privateKey = Buffer.from(handle.slice(0, 64), \"hex\");\n      this.chainCode = Buffer.from(handle.slice(64), \"hex\");\n    } else {\n      throw new Error(\"master handle was not of expected type\");\n    }\n  }\n\n  /**\n   * get the account handle\n   */\n  get handle () {\n    return getHandle(this)\n  }\n\n  /**\n   * creates a sub key seed for validating\n   *\n   * @param path - the string to use as a sub path\n   */\n  private generateSubHDKey = (pathString: string): HDKey =>\n    generateSubHDKey(this, pathString)\n\n  uploadFile = (dir: string, file: File) =>\n    uploadFile(this, dir, file)\n\n  downloadFile = (handle: string) =>\n    downloadFile(this, handle)\n\n  /**\n   * deletes every version of a file and removes it from the metadata\n   *\n   * @param dir - the containing folder\n   * @param file - file entry to delete (loosely matched name)\n   */\n  deleteFile = (dir: string, file: FileEntryMeta) =>\n    deleteFile(this, dir, file)\n\n  /**\n   * deletes a single version of a file (ie. delete by handle)\n   *\n   * @param dir - the containing folder\n   * @param version - version to delete (loosely matched by handle)\n   */\n  deleteVersion = (dir: string, version: FileVersion) =>\n    deleteVersion(this, dir, version)\n\n  /**\n   * creates a dir key seed for validating and folder navigation\n   *\n   * @param dir - the folder\n   */\n  getFolderHDKey = (dir: string) =>\n    getFolderHDKey(this, dir)\n\n  /**\n   * get the location (ie. metadata id) of a folder\n   *\n   * @remarks this is a deterministic location derived from the account's hdkey to allow for random folder access\n   *\n   * @param dir - the folder to locate\n   */\n  getFolderLocation = (dir: string) =>\n    getFolderLocation(this, dir)\n\n  /**\n   * request the creation of a folder metadata\n   *\n   * @param dir - the folder to create\n   */\n  createFolderMeta = async (dir: string) =>\n    createFolderMeta(this, dir)\n\n  /**\n   * create folder {name} inside of {dir}\n   *\n   * @param dir - the containing folder\n   * @param name - the name of the new folder\n   */\n  createFolder = async (dir: string, name: string) =>\n    createFolder(this, dir, name)\n\n  deleteFolderMeta = async (dir: string) =>\n    deleteFolderMeta(this, dir)\n\n  deleteFolder = async (dir: string, folder: FolderEntryMeta) =>\n    deleteFolder(this, dir, folder)\n\n  moveFile = async (dir: string, { file, to }: MoveFileArgs) =>\n    moveFile(this, dir, { file, to })\n\n  moveFolder = async (dir: string, { folder, to }: MoveFolderArgs) =>\n    moveFolder(this, dir, { folder, to })\n\n  renameFile = async (dir: string, { file, name }: RenameFileArgs) =>\n    renameFile(this, dir, { file, name })\n\n  renameFolder = async (dir: string, { folder, name }: RenameFolderArgs) =>\n    renameFolder(this, dir, { folder, name })\n\n  setFolderMeta = async (dir: string, folderMeta: FolderMeta) =>\n    setFolderMeta(this, dir, folderMeta)\n\n  getFolderMeta = async (dir: string): Promise<FolderMeta> =>\n    getFolderMeta(this, dir)\n\n  /**\n   * recursively build full file tree starting from directory {dir}\n   *\n   * @param dir - the starting directory\n   */\n  buildFullTree = async (dir: string): Promise<{ [dir: string]: FolderMeta }> =>\n    buildFullTree(this, dir)\n\n  getAccountInfo = async () =>\n    getAccountInfo(this)\n\n  isExpired = async () =>\n    isExpired(this)\n\n  isPaid = async () =>\n    isPaid(this)\n\n  login = async () =>\n    login(this)\n\n  register = async (duration?: number, limit?: number) =>\n    register(this, duration, limit)\n\n  upgrade = async (duration?: number, limit?: number) =>\n    upgradeAccount(this, duration, limit)\n\n  renew = async (duration?: number) =>\n    renewAccount(this, duration)\n}\n\nexport { Account, MasterHandle, MasterHandleCreator, MasterHandleOptions, HDKey };\n","import { CryptoMiddleware, NetworkMiddleware } from \"@opacity/middleware\"\nimport { extractPromise } from \"@opacity/util/src/promise\"\nimport { getPayload } from \"@opacity/util/src/payload\"\nimport { bytesToHex } from \"@opacity/util/src/hex\"\nimport { bytesToB64URL } from \"@opacity/util/src/b64\"\n\nexport type AccountPlanInfo = {\n\tname: string\n\tcost: number\n\tcostInUSD: number\n\tstorageInGB: number\n\tmaxFolders: number\n\tmaxMetadataSizeInMB: number\n}\n\nexport type AccountPlansRes = {\n\tplans: {\n\t\t[key: number]: AccountPlanInfo\n\t}\n}\n\nexport type AccountCreationPayload = {\n\tdurationInMonths: number\n\tstorageLimit: number\n}\n\nexport type AccountCreationInvoice = {\n\tcost: number\n\tethAddress: string\n}\n\nexport type AccountCreationRes = {\n\texpirationDate: number\n\tinvoice: AccountCreationInvoice\n}\n\nexport type AccountRenewPayload = {\n\tdurationInMonths: number\n}\n\nexport type AccountRenewStatusPayload = {\n\tmetadataKeys: string[]\n\tfileHandles: string[]\n}\n\nexport type AccountRenewInvoice = {\n\tcost: number\n\tethAddress: string\n}\n\nexport type AccountRenewRes = {\n\t// expirationDate: number\n\topctInvoice: AccountRenewInvoice\n}\n\nexport type AccountUpgradePayload = {\n\tstorageLimit: number\n\tdurationInMonths: number\n}\n\nexport type AccountUpgradeStatusPayload = {\n\tmetadataKeys: string[]\n\tfileHandles: string[]\n}\n\nexport type AccountUpgradeInvoice = {\n\tcost: number\n\tethAddress: string\n}\n\nexport type AccountUpgradeRes = {\n\topctInvoice: AccountUpgradeInvoice\n}\n\nexport type AccountGetData = {\n\tcreatedAt: number\n\tupdatedAt: number\n\texpirationDate: number\n\t// number of months in their subscription\n\tmonthsInSubscription: number\n\t// how much storage they are allowed, in GB\n\tstorageLimit: number\n\t// how much storage they have used, in GB\n\tstorageUsed: number\n\t// the eth address they will send payment to\n\tethAddress: string\n\tcost: number\n\tapiVersion: number\n\ttotalFolders: number\n\ttotalMetadataSizeInMB: number\n\tmaxFolders: number\n\tmaxMetadataSizeInMB: number\n}\n\nexport type AccountGetStripeData = {\n\tstripePaymentExists: boolean\n\tchargePaid: boolean\n\tstripeToken: string\n\topctTxStatus: string\n\tchargeID: string\n\tamount: number\n}\n\nexport enum AccountPaymentStatus {\n\tUNPAID = \"unpaid\",\n\tPENDING = \"pending\",\n\tPAID = \"paid\",\n\tEXPIRED = \"expired\",\n}\n\nexport enum AccountRenewStatus {\n\tINCOMPLETE = \"Incomplete\",\n\tPAID = \"Success with OPCT\",\n}\n\nexport enum AccountUpgradeStatus {\n\tINCOMPLETE = \"Incomplete\",\n\tPAID = \"Success with OPCT\",\n}\n\nexport type AccountGetRes = {\n\tpaymentStatus: keyof Record<AccountPaymentStatus, string>\n\terror: string\n\taccount: AccountGetData\n\tstripeData: AccountGetStripeData\n\tinvoice?: AccountCreationInvoice\n}\n\nexport type AccountRenewStatusRes = {\n\tstatus: keyof Record<AccountRenewStatus, string>\n}\n\nexport type AccountUpgradeStatusRes = {\n\tstatus: keyof Record<AccountUpgradeStatus, string>\n}\n\nexport type AccountSignupArgs = {\n\tsize?: number\n\tduration?: number\n}\n\nexport type AccountStripeArgs = {\n\tstripeToken?: string\n}\n\nexport type AccountRenewArgs = {\n\tduration?: number\n}\n\nexport type AccountUpgradeArgs = {\n\tsize: number\n\tduration?: number\n}\n\nexport type AccountRenewStatusArgs = {\n\tmetadataKeys: Uint8Array[]\n\tfileIDs: Uint8Array[]\n}\n\nexport type AccountUpgradeStatusArgs = {\n\tmetadataKeys: Uint8Array[]\n\tfileIDs: Uint8Array[]\n}\n\nexport type AccountConfig = {\n\tcrypto: CryptoMiddleware\n\tnet: NetworkMiddleware\n\n\tstorageNode: string\n}\n\nexport class Account {\n\tconfig: AccountConfig\n\n\tconstructor (config: AccountConfig) {\n\t\tthis.config = config\n\t}\n\n\tasync info (): Promise<AccountGetRes> {\n\t\tconst payload = await getPayload({ crypto: this.config.crypto, payload: {} })\n\t\tconst res = await this.config.net.POST<AccountGetRes>(\n\t\t\tthis.config.storageNode + \"/api/v1/account-data\",\n\t\t\tundefined,\n\t\t\tJSON.stringify(payload),\n\t\t\t(body) => new Response(body).json(),\n\t\t)\n\n\t\tif (!res.ok) {\n\t\t\tthrow new Error(\"Error getting account information: \" + JSON.stringify(res.data))\n\t\t}\n\n\t\treturn res.data\n\t}\n\n\tasync createSubscription ({ stripeToken = \"\" }: AccountStripeArgs = {}): Promise<AccountGetRes> {\n\t\tconst payload = await getPayload({ crypto: this.config.crypto, payload: { stripeToken } })\n\t\tconst res = await this.config.net.POST(\n\t\t\tthis.config.storageNode + \"/api/v1/stripe/create\",\n\t\t\tundefined,\n\t\t\tJSON.stringify(payload),\n\t\t\t(body) => new Response(body).json(),\n\t\t)\n\n\t\tif (!res.ok) {\n\t\t\tthrow new Error(\"Error getting Stripe information: \" + JSON.stringify(res.data))\n\t\t}\n\n\t\treturn res.data\n\t}\n\n\tasync plans () {\n\t\tconst res = await this.config.net.GET(\n\t\t\tthis.config.storageNode + \"/plans\",\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t(body) => new Response(body).json() as Promise<AccountPlansRes>,\n\t\t)\n\n\t\t// TODO: add filter for custom plans\n\t\t// filter plan by size to prevent custom plans from showing up\n\t\tconst plans: AccountPlanInfo[] = Object.values(res.data.plans).filter((plan) => plan.storageInGB <= 2048)\n\n\t\treturn plans\n\t}\n\n\tasync status (): Promise<AccountPaymentStatus> {\n\t\tconst info = await this.info()\n\t\treturn info.paymentStatus\n\t}\n\n\tasync signUp ({ size = 128, duration = 12 }: AccountSignupArgs = {}): Promise<AccountCreationInvoice> {\n\t\ttry {\n\t\t\tconst info = await this.info()\n\n\t\t\tif (info.invoice) {\n\t\t\t\treturn info.invoice\n\t\t\t}\n\n\t\t\tif (info.paymentStatus == AccountPaymentStatus.PAID) {\n\t\t\t\treturn {\n\t\t\t\t\tcost: 0,\n\t\t\t\t\tethAddress: \"\",\n\t\t\t\t}\n\t\t\t}\n\t\t} catch {}\n\n\t\tconst payload = await getPayload<AccountCreationPayload>({\n\t\t\tcrypto: this.config.crypto,\n\t\t\tpayload: {\n\t\t\t\tdurationInMonths: duration,\n\t\t\t\tstorageLimit: size,\n\t\t\t},\n\t\t})\n\t\tconst res = await this.config.net.POST<AccountCreationRes>(\n\t\t\tthis.config.storageNode + \"/api/v1/accounts\",\n\t\t\tundefined,\n\t\t\tJSON.stringify(payload),\n\t\t\t(body) => new Response(body).json(),\n\t\t)\n\n\t\tif (!res.ok || !res.data.invoice) {\n\t\t\tthrow new Error(\"Error getting invoice\")\n\t\t}\n\n\t\treturn res.data.invoice\n\t}\n\n\tasync waitForPayment (): Promise<void> {\n\t\tconst [done, resolveDone] = extractPromise<void>()\n\n\t\tlet iTime = 2\n\n\t\tconst iFn = async () => {\n\t\t\tconst status = await this.status()\n\n\t\t\tif (status == AccountPaymentStatus.PAID) {\n\t\t\t\tresolveDone()\n\t\t\t}\n\t\t\telse {\n\t\t\t\tiTime *= 2\n\t\t\t\tif (iTime > 10) {\n\t\t\t\t\tiTime = 10\n\t\t\t\t}\n\t\t\t\tsetTimeout(iFn, iTime * 1000)\n\t\t\t}\n\t\t}\n\n\t\tsetTimeout(iFn, iTime)\n\n\t\tawait done\n\t}\n\n\tasync renewStatus ({ fileIDs, metadataKeys }: AccountRenewStatusArgs): Promise<AccountRenewStatus> {\n\t\tconst payload = await getPayload<AccountRenewStatusPayload>({\n\t\t\tcrypto: this.config.crypto,\n\t\t\tpayload: {\n\t\t\t\tfileHandles: fileIDs.map((id) => bytesToHex(id)),\n\t\t\t\tmetadataKeys: metadataKeys.map((key) => bytesToB64URL(key)),\n\t\t\t},\n\t\t})\n\t\tconst res = await this.config.net.POST<AccountRenewStatusRes>(\n\t\t\tthis.config.storageNode + \"/api/v2/renew\",\n\t\t\tundefined,\n\t\t\tJSON.stringify(payload),\n\t\t\t(body) => new Response(body).json(),\n\t\t)\n\n\t\tif (!res.ok || !res.data.status) {\n\t\t\tthrow new Error(\"Error getting renewal status\")\n\t\t}\n\n\t\treturn res.data.status\n\t}\n\n\tasync renewAccount ({ duration = 12 }: AccountRenewArgs): Promise<AccountRenewInvoice> {\n\t\ttry {\n\t\t\tconst info = await this.info()\n\n\t\t\tif (info.invoice) {\n\t\t\t\treturn info.invoice\n\t\t\t}\n\t\t} catch {}\n\n\t\tconst payload = await getPayload<AccountRenewPayload>({\n\t\t\tcrypto: this.config.crypto,\n\t\t\tpayload: {\n\t\t\t\tdurationInMonths: duration,\n\t\t\t},\n\t\t})\n\t\tconst res = await this.config.net.POST<AccountRenewRes>(\n\t\t\tthis.config.storageNode + \"/api/v2/renew/invoice\",\n\t\t\tundefined,\n\t\t\tJSON.stringify(payload),\n\t\t\t(body) => new Response(body).json(),\n\t\t)\n\n\t\tif (!res.ok || !res.data.opctInvoice) {\n\t\t\tthrow new Error(\"Error getting renewal invoice\")\n\t\t}\n\n\t\treturn res.data.opctInvoice\n\t}\n\n\tasync waitForRenewPayment (renewStatusArgs: AccountRenewStatusArgs): Promise<void> {\n\t\tconst [done, resolveDone] = extractPromise<void>()\n\n\t\tlet iTime = 2\n\n\t\tconst iFn = async () => {\n\t\t\tconst status = await this.renewStatus(renewStatusArgs)\n\n\t\t\tif (status == AccountRenewStatus.PAID) {\n\t\t\t\tresolveDone()\n\t\t\t}\n\t\t\telse {\n\t\t\t\tiTime *= 2\n\t\t\t\tif (iTime > 10) {\n\t\t\t\t\tiTime = 10\n\t\t\t\t}\n\t\t\t\tsetTimeout(iFn, iTime * 1000)\n\t\t\t}\n\t\t}\n\n\t\tsetTimeout(iFn, iTime)\n\n\t\tawait done\n\t}\n\n\tasync upgradeStatus ({ fileIDs, metadataKeys }: AccountUpgradeStatusArgs): Promise<AccountUpgradeStatus> {\n\t\tconst payload = await getPayload<AccountUpgradeStatusPayload>({\n\t\t\tcrypto: this.config.crypto,\n\t\t\tpayload: {\n\t\t\t\tfileHandles: fileIDs.map((id) => bytesToHex(id)),\n\t\t\t\tmetadataKeys: metadataKeys.map((key) => bytesToB64URL(key)),\n\t\t\t},\n\t\t})\n\t\tconst res = await this.config.net.POST<AccountUpgradeStatusRes>(\n\t\t\tthis.config.storageNode + \"/api/v2/upgrade\",\n\t\t\tundefined,\n\t\t\tJSON.stringify(payload),\n\t\t\t(body) => new Response(body).json(),\n\t\t)\n\n\t\tif (!res.ok || !res.data.status) {\n\t\t\tthrow new Error(\"Error getting upgrade status\")\n\t\t}\n\n\t\treturn res.data.status\n\t}\n\n\tasync upgradeAccount ({ size, duration = 12 }: AccountUpgradeArgs): Promise<AccountUpgradeInvoice> {\n\t\ttry {\n\t\t\tconst info = await this.info()\n\n\t\t\tif (info.invoice) {\n\t\t\t\treturn info.invoice\n\t\t\t}\n\t\t} catch {}\n\n\t\tconst payload = await getPayload<AccountUpgradePayload>({\n\t\t\tcrypto: this.config.crypto,\n\t\t\tpayload: {\n\t\t\t\tstorageLimit: size,\n\t\t\t\tdurationInMonths: duration,\n\t\t\t},\n\t\t})\n\t\tconst res = await this.config.net.POST<AccountUpgradeRes>(\n\t\t\tthis.config.storageNode + \"/api/v2/upgrade/invoice\",\n\t\t\tundefined,\n\t\t\tJSON.stringify(payload),\n\t\t\t(body) => new Response(body).json(),\n\t\t)\n\n\t\tif (!res.ok || !res.data.opctInvoice) {\n\t\t\tthrow new Error(\"Error getting upgrade invoice\")\n\t\t}\n\n\t\treturn res.data.opctInvoice\n\t}\n\n\tasync waitForUpgradePayment (UpgradeStatusArgs: AccountUpgradeStatusArgs): Promise<void> {\n\t\tconst [done, resolveDone] = extractPromise<void>()\n\n\t\tlet iTime = 2\n\n\t\tconst iFn = async () => {\n\t\t\tconst status = await this.upgradeStatus(UpgradeStatusArgs)\n\n\t\t\tif (status == AccountUpgradeStatus.PAID) {\n\t\t\t\tresolveDone()\n\t\t\t}\n\t\t\telse {\n\t\t\t\tiTime *= 2\n\t\t\t\tif (iTime > 10) {\n\t\t\t\t\tiTime = 10\n\t\t\t\t}\n\t\t\t\tsetTimeout(iFn, iTime * 1000)\n\t\t\t}\n\t\t}\n\n\t\tsetTimeout(iFn, iTime)\n\n\t\tawait done\n\t}\n}\n","export {\n\tAccountSystem,\n\tAccountSystemAlreadyExistsError,\n\tAccountSystemConfig,\n\tAccountSystemLengthError,\n\tAccountSystemNotEmptyError,\n\tAccountSystemNotFoundError,\n\tAccountSystemSanitizationError,\n\tFileCreationMetadata,\n\tFileMetadata,\n\tFilesIndex,\n\tFilesIndexEntry,\n\tFolderFileEntry,\n\tFolderMetadata,\n\tFoldersIndex,\n\tFoldersIndexEntry,\n\tShareFileMetadata,\n\tShareFileMetadataInit,\n\tShareIndex,\n\tShareIndexEntry,\n\tShareMetadata,\n} from \"./AccountSystem\"\nexport { MetadataAccess, MetadataAccessConfig } from \"./MetadataAccess\"\n","import { bytesToHex } from \"@opacity/util/src/hex\"\nimport { CryptoMiddleware, NetworkMiddleware } from \"@opacity/middleware\"\nimport { FileMeta } from \"./filemeta\"\nimport { FileSystemObjectDeleteEvent } from \"./events\"\nimport { getPayload } from \"@opacity/util/src/payload\"\nimport { serializeEncrypted } from \"@opacity/util/src/serializeEncrypted\"\n\nexport interface IFileSystemObject {\n\treadonly public: boolean\n\treadonly private: boolean\n\n\treadonly handle: Uint8Array | undefined\n\treadonly location: Uint8Array | undefined\n\n\texists(): Promise<boolean>\n\tmetadata(): Promise<FileMeta | undefined>\n\n\t_beforeDelete?: (o: this) => Promise<void>\n\t_afterDelete?: (o: this) => Promise<void>\n\tdelete(): Promise<void>\n}\n\nexport class FileSystemObjectDeletionError extends Error {\n\tconstructor (location: string, err: string) {\n\t\tsuper(`DeletionError: Failed to delete \"${location}\". Error: \"${err}\"`)\n\t}\n}\n\nexport type FileSystemObjectConfig = {\n\tcrypto: CryptoMiddleware\n\tnet: NetworkMiddleware\n\n\tstorageNode: string\n}\n\nexport type FileSystemObjectArgs = {\n\thandle: Uint8Array | undefined\n\tlocation: Uint8Array | undefined\n\n\tconfig: FileSystemObjectConfig\n}\n\nexport class FileSystemObject extends EventTarget implements IFileSystemObject {\n\t_handle?: Uint8Array\n\t_location?: Uint8Array\n\n\tget handle () {\n\t\treturn this._handle\n\t}\n\tget location () {\n\t\treturn this._location\n\t}\n\n\tget public () {\n\t\treturn !!this._location\n\t}\n\tget private () {\n\t\treturn !!this._handle\n\t}\n\n\tconfig: FileSystemObjectConfig\n\n\t_beforeDelete?: (o: FileSystemObject) => Promise<void>\n\t_afterDelete?: (o: FileSystemObject) => Promise<void>\n\n\tconstructor ({ handle, location, config }: FileSystemObjectArgs) {\n\t\tsuper()\n\n\t\tthis._handle = handle\n\t\tthis._location = location\n\n\t\tthis.config = config\n\t}\n\n\tprivate async _getDownloadURL (fileID: Uint8Array) {\n\t\tconst res = await this.config.net.POST(\n\t\t\tthis.config.storageNode + \"/api/v1/download\",\n\t\t\tundefined,\n\t\t\tJSON.stringify({\n\t\t\t\tfileID: bytesToHex(fileID),\n\t\t\t}),\n\t\t\t(b) => new Response(b).text(),\n\t\t)\n\n\t\treturn res\n\t}\n\n\tasync exists () {\n\t\tif (!this._handle && !this._location) {\n\t\t\tconsole.warn(\"filesystem object already deleted\")\n\n\t\t\treturn false\n\t\t}\n\n\t\tif (this._handle) {\n\t\t\tconst fileID = this._handle!.slice(0, 32)\n\n\t\t\tconst res = await this._getDownloadURL(fileID)\n\n\t\t\tif (res.status == 200) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tif (this._location) {\n\t\t\tconst fileID = this._location!.slice(0, 32)\n\n\t\t\tconst res = await this._getDownloadURL(fileID)\n\n\t\t\tif (res.status == 200) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\tasync metadata (): Promise<FileMeta | undefined> {\n\t\tif (!this._handle && !this._location) {\n\t\t\tconsole.warn(\"filesystem object already deleted\")\n\n\t\t\treturn\n\t\t}\n\n\t\tconst fileID = this._location ? this._location.slice(0, 32) : this._handle!.slice(0, 32)\n\n\t\tconst downloadURL = await this._getDownloadURL(fileID)\n\n\t\tconst res = await this.config.net.GET(\n\t\t\tdownloadURL + \"/metadata\",\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tasync (rs) => new Uint8Array(await new Response(rs).arrayBuffer()),\n\t\t)\n\n\t\tif (!res.ok) {\n\t\t\treturn\n\t\t}\n\n\t\tif (this._handle) {\n\t\t\treturn serializeEncrypted<FileMeta>(this.config.crypto, res.data, this._handle.slice(32, 64))\n\t\t}\n\n\t\tif (this._location) {\n\t\t\treturn JSON.parse(new TextDecoder().decode(res.data)) as FileMeta\n\t\t}\n\t}\n\n\tasync delete () {\n\t\tif (!this._handle && !this._location) {\n\t\t\tconsole.warn(\"filesystem object already deleted\")\n\n\t\t\treturn\n\t\t}\n\n\t\tif (this._beforeDelete) {\n\t\t\tawait this._beforeDelete(this)\n\t\t}\n\n\t\tif (this._handle) {\n\t\t\tthis.dispatchEvent(new FileSystemObjectDeleteEvent({}))\n\n\t\t\tconst fileID = this._handle.slice(0, 32)\n\n\t\t\tconst payload = await getPayload({\n\t\t\t\tcrypto: this.config.crypto,\n\t\t\t\tpayload: { fileID: bytesToHex(fileID) },\n\t\t\t})\n\n\t\t\tconst res = await this.config.net.POST(\n\t\t\t\tthis.config.storageNode + \"/api/v1/delete\",\n\t\t\t\tundefined,\n\t\t\t\tJSON.stringify(payload),\n\t\t\t\t(b) => new Response(b).text(),\n\t\t\t)\n\n\t\t\tif (res.status != 200) {\n\t\t\t\tthrow new FileSystemObjectDeletionError(bytesToHex(fileID), res.data)\n\t\t\t}\n\n\t\t\tif (this._afterDelete) {\n\t\t\t\tawait this._afterDelete(this)\n\t\t\t}\n\n\t\t\t// clear sensitive data\n\t\t\tdelete this._handle\n\t\t}\n\n\t\tif (this._location) {\n\t\t\tthis.dispatchEvent(new FileSystemObjectDeleteEvent({}))\n\n\t\t\tconst fileID = this._location.slice(0, 32)\n\n\t\t\tconst payload = await getPayload({\n\t\t\t\tcrypto: this.config.crypto,\n\t\t\t\tpayload: { fileID: bytesToHex(fileID) },\n\t\t\t})\n\n\t\t\tconst res = await this.config.net.POST(\n\t\t\t\tthis.config.storageNode + \"/api/v1/delete\",\n\t\t\t\tundefined,\n\t\t\t\tJSON.stringify(payload),\n\t\t\t\t(b) => new Response(b).text(),\n\t\t\t)\n\n\t\t\tif (res.status != 200) {\n\t\t\t\tthrow new FileSystemObjectDeletionError(bytesToHex(fileID), res.data)\n\t\t\t}\n\n\t\t\tif (this._afterDelete) {\n\t\t\t\tawait this._afterDelete(this)\n\t\t\t}\n\n\t\t\t// clear sensitive data\n\t\t\tdelete this._location\n\t\t}\n\t}\n}\n","export { WebAccountMiddleware, WebAccountMiddlewareArgs } from \"./webAccountMiddleware\"\nexport { WebNetworkMiddleware } from \"./webNetworkMiddleware\"\n","export type ExtractedPromise<T> = [Promise<T>, (v: T | PromiseLike<T>) => void, (reason: any) => void]\n\nexport const extractPromise = <T = void>(): ExtractedPromise<T> => {\n\tlet rs: (v: T | PromiseLike<T>) => void, rj: (reason?: any) => void\n\n\tconst promise = new Promise<T>((resole, reject) => {\n\t\trs = resole\n\t\trj = reject\n\t})\n\n\treturn [promise, rs!, rj!]\n}\n","import { keccak256 } from \"js-sha3\"\n\nimport { CryptoMiddleware } from \"@opacity/middleware\"\nimport { bytesToHex } from \"./hex\"\n\nexport type PayloadArgs<P extends { [key: string]: any } = { [key: string]: any }> = {\n\tcrypto: CryptoMiddleware\n\tpayload: P\n\tkey?: Uint8Array\n\tpayloadKey?: string\n}\n\nexport type PayloadData = {\n\t[payloadKey: string]: string\n\tsignature: string\n\tpublicKey: string\n\thash: string\n}\n\nexport const getPayload = async <P extends { [key: string]: any }>({\n\tcrypto,\n\tpayload: rawPayload,\n\tkey,\n\tpayloadKey = \"requestBody\",\n}: PayloadArgs<P>) => {\n\tObject.assign(rawPayload, { timestamp: Math.floor(Date.now() / 1000) })\n\n\tconst payload = JSON.stringify(rawPayload)\n\tconst hash = new Uint8Array(keccak256.arrayBuffer(payload))\n\tconst signature = await crypto.sign(key, hash)\n\tconst pubKey = await crypto.getPublicKey(key)\n\n\tconst data: PayloadData = {\n\t\t[payloadKey]: payload,\n\t\tsignature: bytesToHex(signature),\n\t\tpublicKey: bytesToHex(pubKey),\n\t\thash: bytesToHex(hash),\n\t}\n\n\treturn data\n}\n\nexport type PayloadFDArgs<\n\tP extends { [key: string]: any } = { [key: string]: any },\n\tEP extends { [key: string]: any } = { [key: string]: Uint8Array }\n> = {\n\tcrypto: CryptoMiddleware\n\tpayload: P\n\textraPayload: EP\n\tkey?: Uint8Array\n\tpayloadKey?: string\n}\n\nexport const getPayloadFD = async <P extends { [key: string]: any }, EP extends { [key: string]: any }>({\n\tcrypto,\n\tpayload: rawPayload,\n\textraPayload,\n\tkey,\n\tpayloadKey = \"requestBody\",\n}: PayloadFDArgs<P, EP>) => {\n\tObject.assign(rawPayload, { timestamp: Math.floor(Date.now() / 1000) })\n\n\tconst payload = JSON.stringify(rawPayload)\n\tconst hash = new Uint8Array(keccak256.arrayBuffer(payload))\n\tconst signature = await crypto.sign(key, hash)\n\tconst pubKey = await crypto.getPublicKey(key)\n\n\tconst data = new FormData()\n\n\tdata.append(payloadKey, payload)\n\tdata.append(\"signature\", bytesToHex(signature))\n\tdata.append(\"publicKey\", bytesToHex(pubKey))\n\tdata.append(\"hash\", bytesToHex(hash))\n\n\tif (extraPayload) {\n\t\tObject.keys(extraPayload).forEach((key) => {\n\t\t\tdata.append(key, new Blob([extraPayload[key].buffer]), key)\n\t\t})\n\t}\n\n\treturn data\n}\n","import { fromUint8Array, toUint8Array } from \"js-base64\"\n\nexport const bytesToB64URL = (b: Uint8Array) => {\n\treturn fromUint8Array(b, true).padEnd(Math.ceil(b.length / 3) * 4, \"=\")\n}\n\nexport const b64URLToBytes = (b64: string) => {\n\treturn toUint8Array(b64)\n}\n","import { Mutex } from \"async-mutex\"\nimport { posix } from \"path-browserify\"\nimport Automerge from \"automerge/src/automerge\"\n\nimport { arraysEqual } from \"@opacity/util/src/arrayEquality\"\nimport { bytesToB64URL } from \"@opacity/util/src/b64\"\nimport { bytesToHex } from \"@opacity/util/src/hex\"\nimport { cleanPath, isPathChild } from \"@opacity/util/src/path\"\nimport { entropyToKey } from \"@opacity/util/src/mnemonic\"\nimport { MetadataAccess } from \"./MetadataAccess\"\nimport { arrayMerge } from \"@opacity/util/src/arrayMerge\"\n\nexport type FilePrivateInfo = {\n\t// 64 bytes\n\thandle: Uint8Array | null\n}\n\nexport type FilePublicInfo = {\n\t// 32 bytes\n\tlocation: Uint8Array | null\n\tshortLinks: Uint8Array[]\n}\n\nexport type FilePublicInfoMinimal = {\n\tlocation: Uint8Array | null\n}\n\nexport type FilesIndexEntry = {\n\tlocation: Uint8Array\n\tfinished: boolean\n\tprivate: FilePrivateInfo\n\tpublic: FilePublicInfoMinimal\n\tdeleted: boolean\n\terrored: boolean\n}\n\nexport type FilesIndex = { files: FilesIndexEntry[] }\n\nexport type FileCreationMetadata = {\n\tsize: number\n\tlastModified: number\n\ttype: string\n}\n\nexport type FileMetadata = {\n\tlocation: Uint8Array\n\tname: string\n\tfolderDerive: Uint8Array\n\tsize: number\n\tuploaded: number\n\tmodified: number\n\ttype: string\n\tfinished: boolean\n\tprivate: FilePrivateInfo\n\tpublic: FilePublicInfo\n}\n\nexport type FoldersIndexEntry = {\n\tlocation: Uint8Array\n\tpath: string\n}\n\nexport type FoldersIndex = { folders: FoldersIndexEntry[] }\n\nexport type FolderFileEntry = {\n\tlocation: Uint8Array\n\tname: string\n}\n\nexport type FolderMetadata = {\n\tlocation: Uint8Array\n\tname: string\n\tpath: string\n\tsize: number\n\tuploaded: number\n\tmodified: number\n\tfiles: FolderFileEntry[]\n}\n\nexport type ShareIndexEntry = {\n\t// 32 bytes\n\tlocationKey: Uint8Array\n\t// 32 bytes\n\tencryptionKey: Uint8Array\n\t// 64 bytes []\n\tfileHandles: Uint8Array[]\n\t// 32 bytes []\n\tfileLocations: Uint8Array[]\n}\n\nexport type ShareIndex = { shared: ShareIndexEntry[] }\n\nexport type ShareFileMetadataInit = {\n\t/**\n\t * Metadata location.\n\t * Used to pull in file metadata\n\t */\n\tlocation: Uint8Array\n\t/**\n\t * Path within the shared structure\n\t */\n\tpath: string\n}\n\nexport type ShareFileMetadata = {\n\tname: string\n\tpath: string\n\tsize: number\n\tuploaded: number\n\tmodified: number\n\ttype: string\n\tfinished: boolean\n\tprivate: FilePrivateInfo\n\tpublic: FilePublicInfoMinimal\n}\n\nexport type ShareMetadata = {\n\tlocationKey: Uint8Array\n\tencryptionKey: Uint8Array\n\tdateShared: number\n\tfiles: ShareFileMetadata[]\n}\n\nexport class AccountSystemLengthError extends Error {\n\tconstructor (item: string, min: number, max: number, recieved: number) {\n\t\tsuper(`AccountSystemLengthError: Invalid length of \"${item}\". Expected between ${min} and ${max}. Got ${recieved}`)\n\t}\n}\n\nexport class AccountSystemAlreadyExistsError extends Error {\n\tconstructor (type: string, path: string) {\n\t\tsuper(`AccountSystemAlreadyExistsError: ${type} \"${path}\" already exists`)\n\t}\n}\n\nexport class AccountSystemSanitizationError extends Error {\n\tconstructor (type: string, path: string, illegal: string[]) {\n\t\tsuper(\n\t\t\t`AccountSystemSanitizationError: ${type} \"${path}\" includes illegal characters \"${illegal\n\t\t\t\t.map((s) => `\"${s}\"`)\n\t\t\t\t.join(\", \")}\"`,\n\t\t)\n\t}\n}\n\nexport class AccountSystemNotFoundError extends Error {\n\tconstructor (type: string, path: string) {\n\t\tsuper(`AccountSystemNotFoundError: ${type} \"${path}\" not found`)\n\t}\n}\n\nexport class AccountSystemNotEmptyError extends Error {\n\tconstructor (type: string, path: string, action: string) {\n\t\tsuper(`AccountSystemNotEmptyError: ${type} \"${path}\" must be empty to ${action}`)\n\t}\n}\n\nconst validateFilename = (name: string) => {\n\t// https://serverfault.com/questions/9546/filename-length-limits-on-linux\n\tif (name.length < 1 || name.length > 255) {\n\t\tthrow new AccountSystemLengthError(`filename (\"${name}\")`, 1, 255, name.length)\n\t}\n\n\t//https://stackoverflow.com/questions/457994/what-characters-should-be-restricted-from-a-unix-file-name\n\tif (name.includes(posix.sep) || name.includes(\"\\0\")) {\n\t\tthrow new AccountSystemSanitizationError(\"file\", name, [posix.sep, \"\\0\"])\n\t}\n}\n\nconst validateDirectoryPath = (path: string) => {\n\tif (path == \"/\") {\n\t\treturn\n\t}\n\n\tfor (let dir of path.split(posix.sep).slice(1)) {\n\t\ttry {\n\t\t\tvalidateFilename(dir)\n\t\t} catch (err) {\n\t\t\tif (err instanceof AccountSystemLengthError) {\n\t\t\t\tthrow new AccountSystemLengthError(`directory (\"${dir}\" of \"${path}\")`, 1, 255, dir.length)\n\t\t\t}\n\t\t\telse if (err instanceof AccountSystemSanitizationError) {\n\t\t\t\tthrow new AccountSystemSanitizationError(\"directory\", dir, [posix.sep, \"\\0\"])\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow err\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst unfreezeUint8Array = (arr: Automerge.FreezeObject<Uint8Array>) => {\n\treturn new Uint8Array(Object.values<number>(arr))\n}\n\nexport type AccountSystemConfig = {\n\tmetadataAccess: MetadataAccess\n}\n\nexport class AccountSystem {\n\tconfig: AccountSystemConfig\n\n\tguid = \"5b7c0640-bc3a-4fa8-b588-ca6a922c1475\"\n\tversion = 2\n\tprefix = \"/\" + this.guid + \"/v\" + this.version\n\n\tindexes = {\n\t\t// preferences: this.prefix + \"/preferences\",\n\t\tfiles: this.prefix + \"/files\",\n\t\tfolders: this.prefix + \"/folders\",\n\t\t// tags: this.prefix + \"/tags\",\n\t\tshare: this.prefix + \"/share\",\n\t}\n\n\t_m = new Mutex()\n\n\tconstructor (config: AccountSystemConfig) {\n\t\tthis.config = config\n\t}\n\n\t///////////////////////////////\n\t///////// Preferences /////////\n\t///////////////////////////////\n\n\t///////////////////////////////\n\t//////////// Files ////////////\n\t///////////////////////////////\n\n\tgetFileDerivePath (location: Uint8Array): string {\n\t\treturn this.prefix + \"/file/\" + bytesToB64URL(location)\n\t}\n\n\tasync getFilesIndex (markCacheDirty = false): Promise<FilesIndex> {\n\t\t// console.log(\"getFilesIndex(\", \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getFilesIndex(markCacheDirty))\n\t}\n\n\tasync _getFilesIndex (markCacheDirty = false): Promise<FilesIndex> {\n\t\t// console.log(\"_getFilesIndex(\", \")\")\n\n\t\tconst filesIndex =\n\t\t\t(await this.config.metadataAccess.get<FilesIndex>(this.indexes.files, markCacheDirty)) ||\n\t\t\tAutomerge.from<FilesIndex>({ files: [] })\n\n\t\t// TODO: find orphans\n\n\t\treturn {\n\t\t\tfiles: filesIndex.files.map((file) => ({\n\t\t\t\tlocation: unfreezeUint8Array(file.location),\n\t\t\t\tfinished: !!file.finished,\n\t\t\t\tprivate: {\n\t\t\t\t\thandle: file?.private?.handle ? unfreezeUint8Array(file.private.handle) : null,\n\t\t\t\t},\n\t\t\t\tpublic: {\n\t\t\t\t\tlocation: file?.public?.location ? unfreezeUint8Array(file.public.location) : null,\n\t\t\t\t},\n\t\t\t\tdeleted: !!file.deleted,\n\t\t\t\terrored: false,\n\t\t\t})),\n\t\t}\n\t}\n\n\tasync getFileMetadataLocationByFileHandle (fileHandle: Uint8Array, markCacheDirty = false): Promise<Uint8Array> {\n\t\t// console.log(\"getFileMetadataLocationByFileHandle(\", fileHandle, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getFileMetadataLocationByFileHandle(fileHandle, markCacheDirty))\n\t}\n\n\tasync _getFileMetadataLocationByFileHandle (fileHandle: Uint8Array, markCacheDirty = false): Promise<Uint8Array> {\n\t\t// console.log(\"_getFileMetadataLocationByFileHandle(\", fileHandle, \")\")\n\n\t\tconst filesIndex = await this._getFilesIndex(markCacheDirty)\n\n\t\tconst fileEntry = filesIndex.files.find(\n\t\t\t(file) => file.private.handle && arraysEqual(file.private.handle, fileHandle),\n\t\t)\n\n\t\tif (!fileEntry) {\n\t\t\tthrow new AccountSystemNotFoundError(\"file of handle\", bytesToHex(fileHandle.slice(0, 32)) + \"...\")\n\t\t}\n\n\t\treturn fileEntry.location\n\t}\n\n\tasync getFileMetadataLocationByFileLocation (fileLocation: Uint8Array, markCacheDirty = false): Promise<Uint8Array> {\n\t\t// console.log(\"getFileMetadataLocationByFileLocation(\", fileLocation, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getFileMetadataLocationByFileHandle(fileLocation, markCacheDirty))\n\t}\n\n\tasync _getFileMetadataLocationByFileLocation (fileLocation: Uint8Array, markCacheDirty = false): Promise<Uint8Array> {\n\t\t// console.log(\"_getFileMetadataLocationByFileLocation(\", fileLocation, \")\")\n\n\t\tconst filesIndex = await this._getFilesIndex(markCacheDirty)\n\n\t\tconst fileEntry = filesIndex.files.find(\n\t\t\t(file) => file.public.location && arraysEqual(file.public.location, fileLocation),\n\t\t)\n\n\t\tif (!fileEntry) {\n\t\t\tthrow new AccountSystemNotFoundError(\"file of handle\", bytesToHex(fileLocation.slice(0, 32)) + \"...\")\n\t\t}\n\n\t\treturn fileEntry.location\n\t}\n\n\tasync getFileIndexEntryByFileMetadataLocation (\n\t\tlocation: Uint8Array,\n\t\tmarkCacheDirty = false,\n\t): Promise<FilesIndexEntry> {\n\t\t// console.log(\"getFileIndexEntryByFileMetadataLocation(\", location, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getFileIndexEntryByFileMetadataLocation(location, markCacheDirty))\n\t}\n\n\tasync _getFileIndexEntryByFileMetadataLocation (\n\t\tlocation: Uint8Array,\n\t\tmarkCacheDirty = false,\n\t): Promise<FilesIndexEntry> {\n\t\t// console.log(\"_getFileIndexEntryByFileMetadataLocation(\", location, \")\")\n\n\t\tconst filesIndex = await this._getFilesIndex(markCacheDirty)\n\t\tconst fileEntry = filesIndex.files.find((file) => arraysEqual(file.location, location))\n\n\t\tif (!fileEntry) {\n\t\t\t// TODO: orphan?\n\t\t\tthrow new AccountSystemNotFoundError(\"file\", bytesToB64URL(location))\n\t\t}\n\n\t\treturn {\n\t\t\tlocation: fileEntry.location,\n\t\t\tfinished: !!fileEntry.finished,\n\t\t\tprivate: {\n\t\t\t\thandle: fileEntry.private.handle,\n\t\t\t},\n\t\t\tpublic: {\n\t\t\t\tlocation: fileEntry.public.location,\n\t\t\t},\n\t\t\tdeleted: !!fileEntry.deleted,\n\t\t\terrored: !!fileEntry.errored,\n\t\t}\n\t}\n\n\tasync getFileMetadata (location: Uint8Array, markCacheDirty = false): Promise<FileMetadata> {\n\t\t// console.log(\"getFileMetadata(\", location, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getFileMetadata(location, markCacheDirty))\n\t}\n\n\tasync _getFileMetadata (location: Uint8Array, markCacheDirty = false): Promise<FileMetadata> {\n\t\t// console.log(\"_getFileMetadata(\", location, \")\")\n\n\t\tconst filePath = this.getFileDerivePath(location)\n\n\t\tconst doc = await this.config.metadataAccess.get<FileMetadata>(filePath, markCacheDirty)\n\n\t\tif (!doc) {\n\t\t\tthrow new AccountSystemNotFoundError(\"file\", filePath)\n\t\t}\n\n\t\treturn {\n\t\t\tlocation: unfreezeUint8Array(doc.location),\n\t\t\tname: doc.name,\n\t\t\tfolderDerive: unfreezeUint8Array(doc.folderDerive),\n\t\t\tsize: doc.size,\n\t\t\tuploaded: doc.uploaded,\n\t\t\tmodified: doc.modified,\n\t\t\ttype: doc.type,\n\t\t\tfinished: !!doc.finished,\n\t\t\tprivate: {\n\t\t\t\thandle: doc?.private?.handle ? unfreezeUint8Array(doc.private.handle) : null,\n\t\t\t},\n\t\t\tpublic: {\n\t\t\t\tlocation: doc?.public?.location ? unfreezeUint8Array(doc.public.location) : null,\n\t\t\t\tshortLinks: doc.public.shortLinks.map((s) => unfreezeUint8Array(s)),\n\t\t\t},\n\t\t}\n\t}\n\n\tasync addUpload (\n\t\t// 32 bytes\n\t\tfileLocation: Uint8Array,\n\t\t// 32 bytes\n\t\tfileEncryptionKey: Uint8Array | undefined,\n\t\tpath: string,\n\t\tfilename: string,\n\t\tmeta: FileCreationMetadata,\n\t\tpub: boolean,\n\t\tmarkCacheDirty = false,\n\t): Promise<FileMetadata> {\n\t\t// console.log(\"addUpload(\", handle, path, filename, meta, pub, \")\")\n\n\t\treturn await this._m.runExclusive(() =>\n\t\t\tthis._addUpload(fileLocation, fileEncryptionKey, path, filename, meta, pub, markCacheDirty),\n\t\t)\n\t}\n\n\tasync _addUpload (\n\t\tfileLocation: Uint8Array,\n\t\tfileEncryptionKey: Uint8Array | undefined,\n\t\tpath: string,\n\t\tfilename: string,\n\t\tmeta: FileCreationMetadata,\n\t\tpub: boolean,\n\t\tmarkCacheDirty = false,\n\t): Promise<FileMetadata> {\n\t\t// console.log(\"_addUpload(\", handle, path, filename, meta, pub, \")\")\n\n\t\tpath = cleanPath(path)\n\t\tvalidateDirectoryPath(path)\n\t\tvalidateFilename(filename)\n\n\t\tconst folder = await this._addFolder(path, markCacheDirty)\n\t\tconst folderDerive = folder.location\n\n\t\tconst metaLocation = await this.config.metadataAccess.config.crypto.getRandomValues(32)\n\t\tconst filePath = this.getFileDerivePath(metaLocation)\n\n\t\tconst fileHandle = fileEncryptionKey ? arrayMerge(fileLocation, fileEncryptionKey) : fileLocation\n\n\t\tawait this.config.metadataAccess.change<FilesIndex>(\n\t\t\tthis.indexes.files,\n\t\t\t`Add file \"${bytesToB64URL(metaLocation)}\" to file index`,\n\t\t\t(doc) => {\n\t\t\t\tif (!doc.files) {\n\t\t\t\t\tdoc.files = []\n\t\t\t\t}\n\t\t\t\tdoc.files.push({\n\t\t\t\t\tlocation: metaLocation,\n\t\t\t\t\tfinished: false,\n\t\t\t\t\tprivate: {\n\t\t\t\t\t\thandle: pub ? null : fileHandle,\n\t\t\t\t\t},\n\t\t\t\t\tpublic: {\n\t\t\t\t\t\tlocation: pub ? fileLocation : null,\n\t\t\t\t\t},\n\t\t\t\t\tdeleted: false,\n\t\t\t\t\terrored: false,\n\t\t\t\t})\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\tconst file = await this.config.metadataAccess.change<FileMetadata>(\n\t\t\tfilePath,\n\t\t\t`Init file metadata for \"${bytesToB64URL(metaLocation)}\"`,\n\t\t\t(doc) => {\n\t\t\t\tdoc.location = metaLocation\n\t\t\t\tdoc.name = filename\n\t\t\t\tdoc.folderDerive = folderDerive\n\t\t\t\tdoc.modified = meta.lastModified\n\t\t\t\tdoc.size = meta.size\n\t\t\t\tdoc.type = meta.type\n\t\t\t\tdoc.uploaded = Date.now()\n\t\t\t\tdoc.finished = false\n\t\t\t\tdoc.private = {\n\t\t\t\t\thandle: pub ? null : fileHandle,\n\t\t\t\t}\n\t\t\t\tdoc.public = {\n\t\t\t\t\tlocation: pub ? fileLocation : null,\n\t\t\t\t\tshortLinks: [],\n\t\t\t\t}\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\treturn {\n\t\t\tlocation: unfreezeUint8Array(file.location),\n\t\t\tname: file.name,\n\t\t\tfolderDerive: unfreezeUint8Array(file.folderDerive),\n\t\t\tsize: file.size,\n\t\t\tuploaded: file.uploaded,\n\t\t\tmodified: file.modified,\n\t\t\ttype: file.type,\n\t\t\tfinished: !!file.finished,\n\t\t\tprivate: {\n\t\t\t\thandle: file?.private?.handle ? unfreezeUint8Array(file.private.handle) : null,\n\t\t\t},\n\t\t\tpublic: {\n\t\t\t\tlocation: file?.public?.location ? unfreezeUint8Array(file.public.location) : null,\n\t\t\t\tshortLinks: file.public.shortLinks.map((s) => unfreezeUint8Array(s)),\n\t\t\t},\n\t\t}\n\t}\n\n\tasync finishUpload (location: Uint8Array, markCacheDirty = false): Promise<void> {\n\t\t// console.log(\"finishUpload(\", location, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._finishUpload(location, markCacheDirty))\n\t}\n\n\tasync _finishUpload (location: Uint8Array, markCacheDirty = false): Promise<void> {\n\t\t// console.log(\"_finishUpload(\", location, \")\")\n\n\t\tconst fileMeta = await this.config.metadataAccess.change<FileMetadata>(\n\t\t\tthis.getFileDerivePath(location),\n\t\t\t\"Mark upload finished\",\n\t\t\t(doc) => {\n\t\t\t\tdoc.finished = true\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\tawait this.config.metadataAccess.change<FolderMetadata>(\n\t\t\tthis.getFolderDerivePath(unfreezeUint8Array(fileMeta.folderDerive)),\n\t\t\t`Add file \"${bytesToB64URL(location)}\" to folder`,\n\t\t\t(doc) => {\n\t\t\t\tif (!doc.files) {\n\t\t\t\t\tdoc.files = []\n\t\t\t\t}\n\t\t\t\tdoc.files.push({\n\t\t\t\t\tname: fileMeta.name,\n\t\t\t\t\tlocation: location,\n\t\t\t\t})\n\n\t\t\t\tdoc.modified = Date.now()\n\t\t\t\tdoc.size++\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\tawait this.config.metadataAccess.change<FilesIndex>(\n\t\t\tthis.indexes.files,\n\t\t\t`Mark upload ${bytesToB64URL(location)} finished`,\n\t\t\t(doc) => {\n\t\t\t\tconst fileEntry = doc.files.find((file) => arraysEqual(location, file.location))\n\n\t\t\t\tif (!fileEntry) {\n\t\t\t\t\tthrow new AccountSystemNotFoundError(\n\t\t\t\t\t\t\"file entry\",\n\t\t\t\t\t\t`\"${bytesToB64URL(location)}\" in \"${bytesToB64URL(unfreezeUint8Array(fileMeta.folderDerive))}\"`,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tfileEntry.finished = true\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\t}\n\n\tasync renameFile (location: Uint8Array, newName: string, markCacheDirty = false): Promise<FileMetadata> {\n\t\t// console.log(\"renameFile(\", location, newName, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._renameFile(location, newName, markCacheDirty))\n\t}\n\n\tasync _renameFile (location: Uint8Array, newName: string, markCacheDirty = false): Promise<FileMetadata> {\n\t\t// console.log(\"_renameFile(\", location, newName, \")\")\n\n\t\tvalidateFilename(newName)\n\n\t\tconst fileIndexEntry = await this._getFileIndexEntryByFileMetadataLocation(location, markCacheDirty)\n\t\tif (!fileIndexEntry) {\n\t\t\tthrow new AccountSystemNotFoundError(\"file\", bytesToB64URL(location))\n\t\t}\n\n\t\tconst fileMeta = await this.config.metadataAccess.change<FileMetadata>(\n\t\t\tthis.getFileDerivePath(fileIndexEntry.location),\n\t\t\t\"Rename file\",\n\t\t\t(doc) => {\n\t\t\t\tdoc.name = newName\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\tawait this.config.metadataAccess.change<FolderMetadata>(\n\t\t\tthis.getFolderDerivePath(unfreezeUint8Array(fileMeta.folderDerive)),\n\t\t\t`Rename file ${bytesToB64URL(location)}`,\n\t\t\t(doc) => {\n\t\t\t\tconst fileEntry = doc.files.find((file) => arraysEqual(location, file.location))\n\n\t\t\t\tif (!fileEntry) {\n\t\t\t\t\tthrow new AccountSystemNotFoundError(\n\t\t\t\t\t\t\"file entry\",\n\t\t\t\t\t\t`\"${bytesToB64URL(location)}\" in \"${bytesToB64URL(unfreezeUint8Array(fileMeta.folderDerive))}\"`,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tfileEntry.name = newName\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\treturn {\n\t\t\tlocation: unfreezeUint8Array(fileMeta.location),\n\t\t\tname: fileMeta.name,\n\t\t\tfolderDerive: unfreezeUint8Array(fileMeta.folderDerive),\n\t\t\tsize: fileMeta.size,\n\t\t\tuploaded: fileMeta.uploaded,\n\t\t\tmodified: fileMeta.modified,\n\t\t\ttype: fileMeta.type,\n\t\t\tfinished: !!fileMeta.finished,\n\t\t\tprivate: {\n\t\t\t\thandle: fileMeta?.private?.handle ? unfreezeUint8Array(fileMeta.private.handle) : null,\n\t\t\t},\n\t\t\tpublic: {\n\t\t\t\tlocation: fileMeta?.public?.location ? unfreezeUint8Array(fileMeta.public.location) : null,\n\t\t\t\tshortLinks: fileMeta.public.shortLinks.map((s) => unfreezeUint8Array(s)),\n\t\t\t},\n\t\t}\n\t}\n\n\tasync moveFile (location: Uint8Array, newPath: string, markCacheDirty = false): Promise<FileMetadata> {\n\t\t// console.log(\"moveFile(\", location, newPath, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._moveFile(location, newPath, markCacheDirty))\n\t}\n\n\tasync _moveFile (location: Uint8Array, newPath: string, markCacheDirty = false): Promise<FileMetadata> {\n\t\t// console.log(\"_moveFile(\", location, newPath, \")\")\n\n\t\tnewPath = cleanPath(newPath)\n\t\tvalidateDirectoryPath(newPath)\n\n\t\tconst folder = await this._addFolder(newPath, markCacheDirty)\n\t\tconst folderDerive = folder.location\n\n\t\tconst oldFileMeta = await this._getFileMetadata(location, markCacheDirty)\n\n\t\tconst newFolder = await this._addFolder(newPath, markCacheDirty)\n\n\t\tawait this.config.metadataAccess.change<FolderMetadata>(\n\t\t\tthis.getFolderDerivePath(newFolder.location),\n\t\t\t`Move file ${bytesToB64URL(location)}`,\n\t\t\t(doc) => {\n\t\t\t\tdoc.files.push({\n\t\t\t\t\tlocation,\n\t\t\t\t\tname: oldFileMeta.name,\n\t\t\t\t})\n\n\t\t\t\tdoc.modified = Date.now()\n\t\t\t\tdoc.size++\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\tawait this.config.metadataAccess.change<FolderMetadata>(\n\t\t\tthis.getFolderDerivePath(oldFileMeta.folderDerive),\n\t\t\t`Move file ${bytesToB64URL(location)}`,\n\t\t\t(doc) => {\n\t\t\t\tconst fileEntryIndex = doc.files.findIndex((file) => arraysEqual(location, file.location))\n\n\t\t\t\tif (fileEntryIndex == -1) {\n\t\t\t\t\tthrow new AccountSystemNotFoundError(\n\t\t\t\t\t\t\"file entry\",\n\t\t\t\t\t\t`\"${bytesToB64URL(location)}\" in \"${bytesToB64URL(oldFileMeta.folderDerive)}\"`,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tdoc.files.splice(fileEntryIndex, 1)\n\n\t\t\t\tdoc.modified = Date.now()\n\t\t\t\tdoc.size--\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\tconst newFileMeta = await this.config.metadataAccess.change<FileMetadata>(\n\t\t\tthis.getFileDerivePath(location),\n\t\t\t\"Move file\",\n\t\t\t(doc) => {\n\t\t\t\tdoc.folderDerive = folderDerive\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\treturn {\n\t\t\tlocation: unfreezeUint8Array(newFileMeta.location),\n\t\t\tname: newFileMeta.name,\n\t\t\tfolderDerive: unfreezeUint8Array(newFileMeta.folderDerive),\n\t\t\tsize: newFileMeta.size,\n\t\t\tuploaded: newFileMeta.uploaded,\n\t\t\tmodified: newFileMeta.modified,\n\t\t\ttype: newFileMeta.type,\n\t\t\tfinished: !!newFileMeta.finished,\n\t\t\tprivate: {\n\t\t\t\thandle: newFileMeta?.private?.handle ? unfreezeUint8Array(newFileMeta.private.handle) : null,\n\t\t\t},\n\t\t\tpublic: {\n\t\t\t\tlocation: newFileMeta?.public?.location ? unfreezeUint8Array(newFileMeta.public.location) : null,\n\t\t\t\tshortLinks: newFileMeta.public.shortLinks.map((s) => unfreezeUint8Array(s)),\n\t\t\t},\n\t\t}\n\t}\n\tasync removeFile (location: Uint8Array, markCacheDirty = false) {\n\t\t// console.log(\"removeFile(\", location, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._removeFile(location, markCacheDirty))\n\t}\n\n\tasync _removeFile (location: Uint8Array, markCacheDirty = false) {\n\t\t// console.log(\"_removeFile(\", location, \")\")\n\n\t\tawait this.config.metadataAccess.change<FilesIndex>(\n\t\t\tthis.indexes.files,\n\t\t\t\"Mark upload deleted\",\n\t\t\t(doc) => {\n\t\t\t\tconst fileEntry = doc.files.find((file) => arraysEqual(unfreezeUint8Array(file.location), location))\n\n\t\t\t\tif (!fileEntry) {\n\t\t\t\t\tthrow new AccountSystemNotFoundError(\"file entry\", bytesToB64URL(location))\n\t\t\t\t}\n\n\t\t\t\tfileEntry.deleted = true\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\tconst fileMeta = await this._getFileMetadata(location, markCacheDirty)\n\t\tawait this.config.metadataAccess.delete(this.getFileDerivePath(location))\n\n\t\tawait this.config.metadataAccess.change<FolderMetadata>(\n\t\t\tthis.getFolderDerivePath(fileMeta.folderDerive),\n\t\t\t`Remove file ${location}`,\n\t\t\t(doc) => {\n\t\t\t\tconst fileIndex = doc.files.findIndex((file) => arraysEqual(unfreezeUint8Array(file.location), location))\n\n\t\t\t\tdoc.files.splice(fileIndex, 1)\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\t}\n\n\t///////////////////////////////\n\t/////////// Folders ///////////\n\t///////////////////////////////\n\n\tgetFolderDerivePath (location: Uint8Array): string {\n\t\treturn this.prefix + \"/folder/\" + bytesToB64URL(location)\n\t}\n\n\tasync getFoldersIndex (markCacheDirty = false): Promise<FoldersIndex> {\n\t\t// console.log(\"getFoldersIndex(\", \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getFoldersIndex(markCacheDirty))\n\t}\n\n\tasync _getFoldersIndex (markCacheDirty = false): Promise<FoldersIndex> {\n\t\t// console.log(\"_getFoldersIndex(\", \")\")\n\n\t\tconst foldersIndex =\n\t\t\t(await this.config.metadataAccess.get<FoldersIndex>(this.indexes.folders, markCacheDirty)) ||\n\t\t\tAutomerge.from<FoldersIndex>({ folders: [] })\n\n\t\t// TODO: find orphans\n\n\t\tconst duplicates = new Set(\n\t\t\t(foldersIndex.folders || []).map(({ path }) => path).filter((p, i, arr) => arr.indexOf(p) != i),\n\t\t)\n\n\t\t// TODO: merge duplicate folders\n\t\tfor (let dup of duplicates) {\n\t\t}\n\n\t\t// TODO: find underlying cause of folders being undefined\n\t\treturn {\n\t\t\tfolders: (foldersIndex.folders || []).map((folder) => ({\n\t\t\t\tlocation: unfreezeUint8Array(folder.location),\n\t\t\t\tpath: folder.path,\n\t\t\t})),\n\t\t}\n\t}\n\n\tasync getFolderIndexEntryByPath (path: string, markCacheDirty = false): Promise<FoldersIndexEntry> {\n\t\t// console.log(\"getFolderIndexEntryByPath(\", path, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getFolderIndexEntryByPath(path, markCacheDirty))\n\t}\n\n\tasync _getFolderIndexEntryByPath (path: string, markCacheDirty = false): Promise<FoldersIndexEntry> {\n\t\t// console.log(\"_getFolderIndexEntryByPath(\", path, \")\")\n\n\t\tpath = cleanPath(path)\n\t\tvalidateDirectoryPath(path)\n\n\t\tconst foldersIndex = await this._getFoldersIndex(markCacheDirty)\n\t\tconst folderEntry = foldersIndex.folders.find((folder) => folder.path == path)\n\n\t\tif (!folderEntry) {\n\t\t\t// TODO: orphan?\n\t\t\tthrow new AccountSystemNotFoundError(\"folder\", path)\n\t\t}\n\n\t\treturn {\n\t\t\tlocation: folderEntry.location,\n\t\t\tpath: folderEntry.path,\n\t\t}\n\t}\n\n\tasync getFoldersInFolderByPath (path: string, markCacheDirty = false): Promise<FoldersIndexEntry[]> {\n\t\t// console.log(\"getFoldersInFolderByPath(\", path, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getFoldersInFolderByPath(path, markCacheDirty))\n\t}\n\n\tasync _getFoldersInFolderByPath (path: string, markCacheDirty = false): Promise<FoldersIndexEntry[]> {\n\t\t// console.log(\"_getFoldersInFolderByPath(\", path, \")\")\n\n\t\tpath = cleanPath(path)\n\t\tvalidateDirectoryPath(path)\n\n\t\tconst foldersIndex = await this._getFoldersIndex(markCacheDirty)\n\n\t\treturn foldersIndex.folders.filter((folder) => isPathChild(path, folder.path))\n\t}\n\n\tasync getAllFoldersInFolderRecursivelyByPath (path: string, markCacheDirty = false): Promise<FoldersIndexEntry[]> {\n\t\t// console.log(\"getAllFoldersInFolderRecursivelyByPath(\", path, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getAllFoldersInFolderRecursivelyByPath(path, markCacheDirty))\n\t}\n\n\tasync _getAllFoldersInFolderRecursivelyByPath (path: string, markCacheDirty = false): Promise<FoldersIndexEntry[]> {\n\t\t// console.log(\"_getAllFoldersInFolderRecursivelyByPath(\", path, \")\")\n\n\t\tpath = cleanPath(path)\n\t\tvalidateDirectoryPath(path)\n\n\t\tconst foldersIndex = await this._getFoldersIndex(markCacheDirty)\n\n\t\treturn (\n\t\t\tawait Promise.all(\n\t\t\t\tfoldersIndex.folders\n\t\t\t\t\t.filter((folder) => isPathChild(path, folder.path))\n\t\t\t\t\t.map(async (folder) => [folder, await this._getAllFoldersInFolderRecursivelyByPath(folder.path)].flat()),\n\t\t\t)\n\t\t).flat()\n\t}\n\n\tasync getAllFilesInFolderRecursivelyByPath (path: string, markCacheDirty = false): Promise<FilesIndexEntry[]> {\n\t\t// console.log(\"getAllFoldersInFolderRecursivelyByPath(\", path, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getAllFilesInFolderRecursivelyByPath(path, markCacheDirty))\n\t}\n\n\tasync _getAllFilesInFolderRecursivelyByPath (path: string, markCacheDirty = false): Promise<FilesIndexEntry[]> {\n\t\t// console.log(\"_getAllFoldersInFolderRecursivelyByPath(\", path, \")\")\n\n\t\tpath = cleanPath(path)\n\t\tvalidateDirectoryPath(path)\n\n\t\tconst folderMeta = await this._getFolderMetadataByPath(path)\n\t\tconst foldersInFolder = await this._getAllFoldersInFolderRecursivelyByPath(path, markCacheDirty)\n\t\tconst filesIndex = await this._getFilesIndex()\n\n\t\tconst filesInFolder = (\n\t\t\tawait Promise.all(\n\t\t\t\tfoldersInFolder.map(async (folder) => (await this._getFolderMetadataByPath(folder.path, markCacheDirty)).files),\n\t\t\t)\n\t\t).flat()\n\n\t\treturn filesIndex.files.filter((fileEntry) =>\n\t\t\t([] as FolderFileEntry[])\n\t\t\t\t.concat(folderMeta.files, filesInFolder)\n\t\t\t\t.some((folderFileEntry) => arraysEqual(folderFileEntry.location, fileEntry.location)),\n\t\t)\n\t}\n\n\tasync getFoldersInFolderByLocation (location: Uint8Array, markCacheDirty = false): Promise<FoldersIndexEntry[]> {\n\t\t// console.log(\"getFoldersInFolderByLocation(\", location, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getFoldersInFolderByLocation(location, markCacheDirty))\n\t}\n\n\tasync _getFoldersInFolderByLocation (location: Uint8Array, markCacheDirty = false): Promise<FoldersIndexEntry[]> {\n\t\t// console.log(\"_getFoldersInFolderByLocation(\", location, \")\")\n\n\t\tconst foldersIndex = await this._getFoldersIndex(markCacheDirty)\n\n\t\tconst folderEntry = foldersIndex.folders.find((folder) => arraysEqual(folder.location, location))\n\n\t\tif (!folderEntry) {\n\t\t\tthrow new AccountSystemNotFoundError(\"folder entry\", bytesToB64URL(location))\n\t\t}\n\n\t\tconst path = folderEntry.path\n\n\t\treturn foldersIndex.folders.filter((folder) => isPathChild(path, folder.path))\n\t}\n\n\tasync getAllFoldersInFolderRecursivelyByLocation (\n\t\tlocation: Uint8Array,\n\t\tmarkCacheDirty = false,\n\t): Promise<FoldersIndexEntry[]> {\n\t\t// console.log(\"getAllFoldersInFolderRecursivelyByLocation(\", location, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getAllFoldersInFolderRecursivelyByLocation(location, markCacheDirty))\n\t}\n\n\tasync _getAllFoldersInFolderRecursivelyByLocation (\n\t\tlocation: Uint8Array,\n\t\tmarkCacheDirty = false,\n\t): Promise<FoldersIndexEntry[]> {\n\t\t// console.log(\"_getAllFoldersInFolderRecursivelyByLocation(\", location, \")\")\n\n\t\tconst foldersIndex = await this._getFoldersIndex(markCacheDirty)\n\n\t\tconst folderEntry = foldersIndex.folders.find((folder) => arraysEqual(folder.location, location))\n\n\t\tif (!folderEntry) {\n\t\t\tthrow new AccountSystemNotFoundError(\"folder entry\", bytesToB64URL(location))\n\t\t}\n\n\t\tconst path = folderEntry.path\n\n\t\treturn (\n\t\t\tawait Promise.all(\n\t\t\t\tfoldersIndex.folders\n\t\t\t\t\t.filter((folder) => isPathChild(path, folder.path))\n\t\t\t\t\t.map(async (folder) =>\n\t\t\t\t\t\t[folder, await this._getAllFoldersInFolderRecursivelyByLocation(folder.location)].flat(),\n\t\t\t\t\t),\n\t\t\t)\n\t\t).flat()\n\t}\n\n\tasync getAllFilesInFolderRecursivelyByLocation (\n\t\tlocation: Uint8Array,\n\t\tmarkCacheDirty = false,\n\t): Promise<FilesIndexEntry[]> {\n\t\t// console.log(\"getAllFoldersInFolderRecursivelyByLocation(\", location, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getAllFilesInFolderRecursivelyByLocation(location, markCacheDirty))\n\t}\n\n\tasync _getAllFilesInFolderRecursivelyByLocation (\n\t\tlocation: Uint8Array,\n\t\tmarkCacheDirty = false,\n\t): Promise<FilesIndexEntry[]> {\n\t\t// console.log(\"_getAllFoldersInFolderRecursivelyByLocation(\", location, \")\")\n\n\t\tconst foldersIndex = await this._getFoldersIndex(markCacheDirty)\n\n\t\tconst folderEntry = foldersIndex.folders.find((folder) => arraysEqual(folder.location, location))\n\n\t\tif (!folderEntry) {\n\t\t\tthrow new AccountSystemNotFoundError(\"folder entry\", bytesToB64URL(location))\n\t\t}\n\n\t\tconst folderMeta = await this._getFolderMetadataByLocation(location)\n\t\tconst foldersInFolder = await this._getAllFoldersInFolderRecursivelyByLocation(folderEntry.location, markCacheDirty)\n\t\tconst filesIndex = await this._getFilesIndex()\n\n\t\tconst filesInFolder = (\n\t\t\tawait Promise.all(\n\t\t\t\tfoldersInFolder.map(\n\t\t\t\t\tasync (folder) => (await this._getFolderMetadataByLocation(folder.location, markCacheDirty)).files,\n\t\t\t\t),\n\t\t\t)\n\t\t).flat()\n\n\t\treturn filesIndex.files.filter((fileEntry) =>\n\t\t\t([] as FolderFileEntry[])\n\t\t\t\t.concat(folderMeta.files, filesInFolder)\n\t\t\t\t.some((folderFileEntry) => arraysEqual(folderFileEntry.location, fileEntry.location)),\n\t\t)\n\t}\n\n\tasync getFolderMetadataByPath (path: string, markCacheDirty = false): Promise<FolderMetadata> {\n\t\t// console.log(\"getFolderMetadataByPath(\", path, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getFolderMetadataByPath(path, markCacheDirty))\n\t}\n\n\tasync _getFolderMetadataByPath (path: string, markCacheDirty = false): Promise<FolderMetadata> {\n\t\t// console.log(\"_getFolderMetadataByPath(\", path, \")\")\n\n\t\tpath = cleanPath(path)\n\n\t\tconst folderEntry = await this._getFolderIndexEntryByPath(path, markCacheDirty)\n\n\t\treturn await this._getFolderMetadataByLocation(folderEntry.location, markCacheDirty)\n\t}\n\n\tasync getFolderMetadataByLocation (location: Uint8Array, markCacheDirty = false): Promise<FolderMetadata> {\n\t\t// console.log(\"getFolderMetadataByLocation(\", location, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getFolderMetadataByLocation(location, markCacheDirty))\n\t}\n\n\tasync _getFolderMetadataByLocation (location: Uint8Array, markCacheDirty = false): Promise<FolderMetadata> {\n\t\t// console.log(\"_getFolderMetadataByLocation(\", location, \")\")\n\n\t\tconst folderPath = this.getFolderDerivePath(location)\n\n\t\tconst doc = await this.config.metadataAccess.get<FolderMetadata>(folderPath, markCacheDirty)\n\n\t\tif (!doc) {\n\t\t\tthrow new AccountSystemNotFoundError(\"folder\", folderPath)\n\t\t}\n\n\t\treturn {\n\t\t\tlocation: unfreezeUint8Array(doc.location),\n\t\t\tname: doc.name,\n\t\t\tpath: doc.path,\n\t\t\tsize: doc.size,\n\t\t\tuploaded: doc.uploaded,\n\t\t\tmodified: doc.modified,\n\t\t\tfiles: doc.files.map((fileEntry) => ({\n\t\t\t\tlocation: unfreezeUint8Array(fileEntry.location),\n\t\t\t\tname: fileEntry.name,\n\t\t\t})),\n\t\t}\n\t}\n\n\tasync addFolder (path: string, markCacheDirty = false): Promise<FolderMetadata> {\n\t\t// console.log(\"addFolder(\", path, \")\")\n\n\t\t// adding folders can result in duplication\n\t\t// marking the cache dirty reduces this risk\n\t\tawait this.config.metadataAccess.markCacheDirty(this.indexes.folders)\n\n\t\treturn await this._m.runExclusive(() => this._addFolder(path, markCacheDirty))\n\t}\n\n\tasync _addFolder (path: string, markCacheDirty = false): Promise<FolderMetadata> {\n\t\t// console.log(\"_addFolder(\", path, \")\")\n\n\t\tpath = cleanPath(path)\n\t\tvalidateDirectoryPath(path)\n\n\t\tif (path != \"/\") {\n\t\t\tawait this._addFolder(posix.dirname(path), markCacheDirty)\n\t\t}\n\n\t\tlet foldersIndexDoc = await this._getFoldersIndex(markCacheDirty)\n\n\t\tconst dup = foldersIndexDoc.folders.find((entry) => entry.path == path)\n\n\t\tif (dup) {\n\t\t\treturn this._getFolderMetadataByLocation(dup.location)\n\t\t}\n\n\t\tconst location = await this.config.metadataAccess.config.crypto.getRandomValues(32)\n\n\t\tawait this.config.metadataAccess.change<FoldersIndex>(\n\t\t\tthis.indexes.folders,\n\t\t\t\"Add folder to index\",\n\t\t\t(doc) => {\n\t\t\t\tif (!doc.folders) {\n\t\t\t\t\tdoc.folders = []\n\t\t\t\t}\n\t\t\t\tdoc.folders.push({\n\t\t\t\t\tlocation: location,\n\t\t\t\t\tpath,\n\t\t\t\t})\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\tconst doc = await this.config.metadataAccess.change<FolderMetadata>(\n\t\t\tthis.getFolderDerivePath(location),\n\t\t\t\"Init folder metadata\",\n\t\t\t(doc) => {\n\t\t\t\tdoc.location = location\n\t\t\t\tdoc.name = posix.basename(path)\n\t\t\t\tdoc.path = path\n\t\t\t\tdoc.modified = Date.now()\n\t\t\t\tdoc.size = 0\n\t\t\t\tdoc.uploaded = Date.now()\n\t\t\t\tdoc.files = []\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\treturn {\n\t\t\tlocation: unfreezeUint8Array(doc.location),\n\t\t\tname: doc.name,\n\t\t\tpath: doc.path,\n\t\t\tsize: doc.size,\n\t\t\tuploaded: doc.uploaded,\n\t\t\tmodified: doc.modified,\n\t\t\tfiles: doc.files.map((file) => ({\n\t\t\t\tlocation: unfreezeUint8Array(file.location),\n\t\t\t\tname: file.name,\n\t\t\t})),\n\t\t}\n\t}\n\n\tasync renameFolder (path: string, newName: string, markCacheDirty = false): Promise<FolderMetadata> {\n\t\t// console.log(\"renameFolder(\", path, newName, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._renameFolder(path, newName, markCacheDirty))\n\t}\n\n\tasync _renameFolder (path: string, newName: string, markCacheDirty = false): Promise<FolderMetadata> {\n\t\t// console.log(\"_renameFolder(\", path, newName, \")\")\n\n\t\tpath = cleanPath(path)\n\t\tvalidateDirectoryPath(path)\n\t\tvalidateFilename(newName)\n\n\t\treturn await this._moveFolder(path, posix.join(posix.dirname(path), newName), markCacheDirty)\n\t}\n\n\tasync moveFolder (oldPath: string, newPath: string, markCacheDirty = false): Promise<FolderMetadata> {\n\t\t// console.log(\"moveFolder(\", oldPath, newPath, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._moveFolder(oldPath, newPath, markCacheDirty))\n\t}\n\n\tasync _moveFolder (oldPath: string, newPath: string, markCacheDirty = false): Promise<FolderMetadata> {\n\t\t// console.log(\"_moveFolder(\", oldPath, newPath, \")\")\n\n\t\toldPath = cleanPath(oldPath)\n\t\tnewPath = cleanPath(newPath)\n\t\tvalidateDirectoryPath(oldPath)\n\t\tvalidateDirectoryPath(newPath)\n\n\t\tconst op = posix.dirname(oldPath) == posix.dirname(newPath) ? \"Rename\" : \"Move\"\n\n\t\tconst newFolder = await this._getFolderIndexEntryByPath(newPath, markCacheDirty).catch(() => {})\n\t\tif (newFolder) {\n\t\t\tthrow new AccountSystemAlreadyExistsError(\"folder\", newPath)\n\t\t}\n\n\t\tconst folderEntry = await this._getFolderIndexEntryByPath(oldPath, markCacheDirty)\n\t\tif (!folderEntry) {\n\t\t\tthrow new AccountSystemNotFoundError(\"folder\", oldPath)\n\t\t}\n\n\t\t// moving folders can result in duplication\n\t\t// marking the cache dirty reduces this risk\n\t\tawait this.config.metadataAccess.markCacheDirty(this.indexes.folders)\n\t\tconst foldersIndex = await this._getFoldersIndex(markCacheDirty)\n\n\t\tawait this.config.metadataAccess.change<FoldersIndex>(\n\t\t\tthis.indexes.folders,\n\t\t\t`${op} folder`,\n\t\t\t(doc) => {\n\t\t\t\tconst subs = doc.folders.filter((folderEntry) => posix.relative(oldPath, folderEntry.path).indexOf(\"../\") != 0)\n\n\t\t\t\tfor (let folderEntry of subs) {\n\t\t\t\t\tfolderEntry.path = posix.join(newPath, posix.relative(oldPath, folderEntry.path))\n\t\t\t\t}\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\tconst subs = foldersIndex.folders.filter((folderEntry) => {\n\t\t\tconst rel = posix.relative(oldPath, folderEntry.path)\n\n\t\t\treturn rel != \"\" && rel.indexOf(\"../\") != 0\n\t\t})\n\n\t\tfor (let folderEntry of subs) {\n\t\t\tawait this.config.metadataAccess.change<FolderMetadata>(\n\t\t\t\tthis.getFolderDerivePath(folderEntry.location),\n\t\t\t\t`${op} folder`,\n\t\t\t\t(doc) => {\n\t\t\t\t\tdoc.path = posix.join(newPath, posix.relative(oldPath, folderEntry.path))\n\t\t\t\t},\n\t\t\t\tmarkCacheDirty,\n\t\t\t)\n\t\t}\n\n\t\tconst doc = await this.config.metadataAccess.change<FolderMetadata>(\n\t\t\tthis.getFolderDerivePath(folderEntry.location),\n\t\t\t`${op} folder`,\n\t\t\t(doc) => {\n\t\t\t\tdoc.name = posix.basename(newPath)\n\t\t\t\tdoc.path = newPath\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\treturn {\n\t\t\tlocation: unfreezeUint8Array(doc.location),\n\t\t\tname: doc.name,\n\t\t\tpath: doc.path,\n\t\t\tsize: doc.size,\n\t\t\tuploaded: doc.uploaded,\n\t\t\tmodified: doc.modified,\n\t\t\tfiles: doc.files.map((file) => ({\n\t\t\t\tlocation: unfreezeUint8Array(file.location),\n\t\t\t\tname: file.name,\n\t\t\t})),\n\t\t}\n\t}\n\n\tasync removeFolderByPath (path: string, markCacheDirty = false): Promise<void> {\n\t\t// console.log(\"removeFolderByPath(\", path, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._removeFolderByPath(path, markCacheDirty))\n\t}\n\n\tasync _removeFolderByPath (path: string, markCacheDirty = false): Promise<void> {\n\t\t// console.log(\"_removeFolderByPath(\", path, \")\")\n\n\t\tpath = cleanPath(path)\n\n\t\tconst folderEntry = await this._getFolderIndexEntryByPath(path, markCacheDirty)\n\n\t\treturn await this._removeFolderByLocation(folderEntry.location, markCacheDirty)\n\t}\n\n\tasync removeFolderByLocation (location: Uint8Array, markCacheDirty = false): Promise<void> {\n\t\t// console.log(\"removeFolderByLocation(\", location, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._removeFolderByLocation(location, markCacheDirty))\n\t}\n\n\tasync _removeFolderByLocation (location: Uint8Array, markCacheDirty = false): Promise<void> {\n\t\t// console.log(\"_removeFolderByLocation(\", location, \")\")\n\n\t\tconst folderMeta = await this._getFolderMetadataByLocation(location, markCacheDirty)\n\n\t\tif (folderMeta.files.length) {\n\t\t\tthrow new AccountSystemNotEmptyError(\"folder\", bytesToB64URL(location), \"remove\")\n\t\t}\n\n\t\tconst childFolders = await this._getFoldersInFolderByLocation(location, markCacheDirty)\n\t\tawait Promise.all(childFolders.map((folder) => this._removeFolderByLocation(folder.location)))\n\n\t\tawait this.config.metadataAccess.delete(this.getFolderDerivePath(location))\n\n\t\tawait this.config.metadataAccess.change<FoldersIndex>(\n\t\t\tthis.indexes.folders,\n\t\t\t`Remove folder ${bytesToB64URL(location)}`,\n\t\t\t(doc) => {\n\t\t\t\tconst folderIndex = doc.folders.findIndex((file) => arraysEqual(unfreezeUint8Array(file.location), location))\n\n\t\t\t\tdoc.folders.splice(folderIndex, 1)\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\t}\n\n\t///////////////////////////////\n\t//////////// Tags  ////////////\n\t///////////////////////////////\n\n\t///////////////////////////////\n\t//////////// Share ////////////\n\t///////////////////////////////\n\n\tgetShareHandle (meta: ShareMetadata | ShareIndexEntry): Uint8Array {\n\t\treturn new Uint8Array(Array.from(meta.locationKey).concat(Array.from(meta.encryptionKey)))\n\t}\n\n\tasync getShareIndex (markCacheDirty = false): Promise<ShareIndex> {\n\t\t// console.log(\"getShareIndex(\", \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getShareIndex(markCacheDirty))\n\t}\n\n\tasync _getShareIndex (markCacheDirty = false): Promise<ShareIndex> {\n\t\t// console.log(\"_getShareIndex(\", \")\")\n\n\t\tconst sharedIndex =\n\t\t\t(await this.config.metadataAccess.get<ShareIndex>(this.indexes.share, markCacheDirty)) ||\n\t\t\tAutomerge.from<ShareIndex>({ shared: [] })\n\n\t\t// TODO: find orphans\n\n\t\treturn {\n\t\t\tshared: sharedIndex.shared.map((shareEntry) => ({\n\t\t\t\tlocationKey: unfreezeUint8Array(shareEntry.locationKey),\n\t\t\t\tencryptionKey: unfreezeUint8Array(shareEntry.encryptionKey),\n\t\t\t\tfileHandles: shareEntry.fileHandles.map((h) => unfreezeUint8Array(h)),\n\t\t\t\tfileLocations: shareEntry.fileLocations.map((l) => unfreezeUint8Array(l)),\n\t\t\t})),\n\t\t}\n\t}\n\n\tasync getSharesByHandle (handle: Uint8Array, markCacheDirty = false) {\n\t\t// console.log(\"getSharesByHandle(\", handle, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._getSharesByHandle(handle, markCacheDirty))\n\t}\n\n\tasync _getSharesByHandle (handle: Uint8Array, markCacheDirty = false): Promise<ShareIndexEntry[]> {\n\t\t// console.log(\"_getSharesByHandle(\", handle, \")\")\n\n\t\tconst shareIndex = await this._getShareIndex(markCacheDirty)\n\n\t\treturn shareIndex.shared.filter((share) => share.fileHandles.findIndex((h) => arraysEqual(handle, h)) != -1)\n\t}\n\n\tasync share (filesInit: ShareFileMetadataInit[], markCacheDirty = false): Promise<ShareMetadata> {\n\t\t// console.log(\"share(\", filesInit, \")\")\n\n\t\treturn await this._m.runExclusive(() => this._share(filesInit, markCacheDirty))\n\t}\n\n\tasync _share (filesInit: ShareFileMetadataInit[], markCacheDirty = false): Promise<ShareMetadata> {\n\t\t// console.log(\"_share(\", filesInit, \")\")\n\n\t\tconst files = await Promise.all(\n\t\t\tfilesInit.map(\n\t\t\t\tasync (fileInit): Promise<ShareFileMetadata> => {\n\t\t\t\t\tconst meta = await this._getFileMetadata(fileInit.location, markCacheDirty)\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmodified: meta.modified,\n\t\t\t\t\t\tuploaded: meta.uploaded,\n\t\t\t\t\t\tname: meta.name,\n\t\t\t\t\t\tpath: fileInit.path,\n\t\t\t\t\t\tsize: meta.size,\n\t\t\t\t\t\ttype: meta.type,\n\t\t\t\t\t\tfinished: !!meta.finished,\n\t\t\t\t\t\tprivate: meta.private,\n\t\t\t\t\t\tpublic: meta.public,\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t),\n\t\t)\n\n\t\tconst locationKey = await entropyToKey(await this.config.metadataAccess.config.crypto.getRandomValues(32))\n\t\tconst encryptionKey = await this.config.metadataAccess.config.crypto.getRandomValues(32)\n\n\t\tawait this.config.metadataAccess.change<ShareIndex>(\n\t\t\tthis.indexes.share,\n\t\t\t\"Share files\",\n\t\t\t(doc) => {\n\t\t\t\tif (!doc.shared) {\n\t\t\t\t\tdoc.shared = []\n\t\t\t\t}\n\t\t\t\tdoc.shared.push({\n\t\t\t\t\tlocationKey,\n\t\t\t\t\tencryptionKey,\n\t\t\t\t\tfileHandles: files.map((f) => f.private.handle!).filter(Boolean),\n\t\t\t\t\tfileLocations: files.map((f) => f.public.location).filter(Boolean) as Uint8Array[],\n\t\t\t\t})\n\t\t\t},\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\tconst shareMeta = await this.config.metadataAccess.changePublic<ShareMetadata>(\n\t\t\tlocationKey,\n\t\t\t\"Share files\",\n\t\t\t(doc) => {\n\t\t\t\tdoc.locationKey = locationKey\n\t\t\t\tdoc.encryptionKey = encryptionKey\n\t\t\t\tdoc.dateShared = Date.now()\n\t\t\t\tdoc.files = files\n\t\t\t},\n\t\t\tencryptionKey,\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\treturn {\n\t\t\tlocationKey: unfreezeUint8Array(shareMeta.locationKey),\n\t\t\tencryptionKey: unfreezeUint8Array(shareMeta.encryptionKey),\n\t\t\tdateShared: shareMeta.dateShared,\n\t\t\tfiles: shareMeta.files.map((file) => ({\n\t\t\t\tname: file.name,\n\t\t\t\tpath: file.path,\n\t\t\t\tsize: file.size,\n\t\t\t\tuploaded: file.uploaded,\n\t\t\t\tmodified: file.modified,\n\t\t\t\ttype: file.type,\n\t\t\t\tfinished: !!file.finished,\n\t\t\t\tprivate: {\n\t\t\t\t\thandle: file?.private?.handle ? unfreezeUint8Array(file.private.handle) : null,\n\t\t\t\t},\n\t\t\t\tpublic: {\n\t\t\t\t\tlocation: file?.public?.location ? unfreezeUint8Array(file.public.location) : null,\n\t\t\t\t},\n\t\t\t})),\n\t\t}\n\t}\n\n\tasync getShared (locationKey: Uint8Array, encryptionKey: Uint8Array, markCacheDirty = false): Promise<ShareMetadata> {\n\t\t// console.log(\"getShared(\", locationKey, encryptionKey, \")\")\n\n\t\tconst handle = arrayMerge(locationKey, encryptionKey)\n\n\t\tconst shareMeta = await this.config.metadataAccess.getPublic<ShareMetadata>(\n\t\t\tlocationKey,\n\t\t\tencryptionKey,\n\t\t\tmarkCacheDirty,\n\t\t)\n\n\t\tif (!shareMeta) {\n\t\t\tthrow new AccountSystemNotFoundError(\"shared\", bytesToB64URL(handle))\n\t\t}\n\n\t\treturn {\n\t\t\tlocationKey: unfreezeUint8Array(shareMeta.locationKey),\n\t\t\tencryptionKey: unfreezeUint8Array(shareMeta.encryptionKey),\n\t\t\tdateShared: shareMeta.dateShared,\n\t\t\tfiles: shareMeta.files.map((file) => ({\n\t\t\t\tname: file.name,\n\t\t\t\tpath: file.path,\n\t\t\t\tsize: file.size,\n\t\t\t\tuploaded: file.uploaded,\n\t\t\t\tmodified: file.modified,\n\t\t\t\ttype: file.type,\n\t\t\t\tfinished: !!file.finished,\n\t\t\t\tprivate: {\n\t\t\t\t\thandle: file?.private?.handle ? unfreezeUint8Array(file.private.handle) : null,\n\t\t\t\t},\n\t\t\t\tpublic: {\n\t\t\t\t\tlocation: file?.public?.location ? unfreezeUint8Array(file.public.location) : null,\n\t\t\t\t},\n\t\t\t})),\n\t\t}\n\t}\n}\n","import { Semaphore } from \"async-mutex\"\nimport Automerge from \"automerge/src/automerge\"\nimport jssha from \"jssha/dist/sha256\"\n\nimport { b64URLToBytes, bytesToB64URL } from \"@opacity/util/src/b64\"\nimport { cleanPath } from \"@opacity/util/src/path\"\nimport { CryptoMiddleware, NetworkMiddleware } from \"@opacity/middleware\"\nimport { DAG, DAGVertex } from \"./dag\"\nimport { getPayload } from \"@opacity/util/src/payload\"\nimport { readUInt32BE, uint32ToUint8BE } from \"@opacity/util/src/uint\"\n\nconst sha256 = (d: Uint8Array): Uint8Array => {\n\tconst digest = new jssha(\"SHA-256\", \"UINT8ARRAY\")\n\tdigest.update(d)\n\treturn digest.getHash(\"UINT8ARRAY\")\n}\n\ntype MetadataGetPayload = {\n\tmetadataV2Key: string\n}\n\ntype MetadataGetRes = {\n\tmetadataV2: string\n\texpirationDate: number\n}\n\ntype MetadataAddPayload = {\n\tmetadataV2Key: string\n\tmetadataV2Vertex: string\n\tmetadataV2Edges: string[]\n\tmetadataV2Sig: string\n\tisPublic: boolean\n}\n\ntype MetadataAddRes = {\n\tMetadataV2Key: string\n\tMetadataV2: string\n\tExpirationDate: number\n}\n\ntype MetadataDeletePayload = {\n\tmetadataV2Key: string\n}\n\ntype MetadataDeleteRes = {\n\tstatus: \"metadataV2 successfully deleted\"\n}\n\nexport type MetadataAccessConfig = {\n\tmetadataNode: string\n\n\tlogging?: boolean\n\n\tcrypto: CryptoMiddleware\n\tnet: NetworkMiddleware\n}\n\nconst packChanges = (changes: Uint8Array[]): Uint8Array => {\n\tconst len = 4 + 4 * changes.length + changes.reduce((acc, cur) => acc + cur.length, 0)\n\tconst packed = new Uint8Array(len)\n\n\tlet i = 0\n\n\tconst lArr = uint32ToUint8BE(changes.length)\n\tpacked[i + 0] = lArr[0]\n\tpacked[i + 1] = lArr[1]\n\tpacked[i + 2] = lArr[2]\n\tpacked[i + 3] = lArr[3]\n\ti += 4\n\n\tfor (let change of changes) {\n\t\tconst lArr2 = uint32ToUint8BE(change.length)\n\t\tpacked[i + 0] = lArr2[0]\n\t\tpacked[i + 1] = lArr2[1]\n\t\tpacked[i + 2] = lArr2[2]\n\t\tpacked[i + 3] = lArr2[3]\n\t\ti += 4\n\n\t\tfor (let n = 0; n < change.length; n++) {\n\t\t\tpacked[i + n] = change[n]\n\t\t}\n\n\t\ti += change.length\n\t}\n\n\treturn packed\n}\n\nconst unpackChanges = (packed: Uint8Array): Uint8Array[] => {\n\tlet i = 0\n\tconst changes: Uint8Array[] = []\n\n\tconst len = readUInt32BE(packed, i)\n\ti += 4\n\n\tfor (let c = 0; c < len; c++) {\n\t\tconst l = readUInt32BE(packed, i)\n\t\ti += 4\n\n\t\tchanges.push(packed.slice(i, i + l))\n\t\ti += l\n\t}\n\n\treturn changes\n}\n\ntype MetadataIndex = {\n\tprivs: {\n\t\t[location: string]: true\n\t}\n\tencryptKeys: {\n\t\t[location: string]: string\n\t}\n}\n\nexport class MetadataAccess {\n\tconfig: MetadataAccessConfig\n\tdags: { [path: string]: DAG } = {}\n\tcache: {\n\t\t[path: string]: {\n\t\t\tlastAccess: number\n\t\t\tdirty: boolean\n\t\t\tdoc: Automerge.Doc<unknown> | undefined\n\t\t}\n\t} = {}\n\n\tmetadataIndexPath = \"/metadata-index\"\n\n\t_sem: Semaphore = new Semaphore(3)\n\n\tconstructor (config: MetadataAccessConfig) {\n\t\tthis.config = config\n\t}\n\n\tasync markCacheDirty (path: string) {\n\t\tconst priv = await this.config.crypto.derive(undefined, path)\n\t\tconst pub = await this.config.crypto.getPublicKey(priv)\n\n\t\treturn this._markCacheDirty(pub)\n\t}\n\n\t_markCacheDirty (pub: Uint8Array) {\n\t\tconst pubString = bytesToB64URL(pub)\n\t\tconst cached = this.cache[pubString]\n\n\t\tif (cached) {\n\t\t\tcached.dirty = true\n\t\t}\n\t}\n\n\tasync getMetadataLocationKeysList (): Promise<Uint8Array[]> {\n\t\tconst priv = await this.config.crypto.derive(undefined, this.metadataIndexPath)\n\n\t\t// do not cache\n\t\tconst metaIndexObject = (await this._get<MetadataIndex>(priv, undefined, true)) || ({} as MetadataIndex)\n\n\t\tconst metaIndexPrivs = [bytesToB64URL(priv)].concat(Object.keys(metaIndexObject.privs))\n\n\t\tconst validLocations = (\n\t\t\tawait Promise.all(\n\t\t\t\tmetaIndexPrivs.map((privString) => {\n\t\t\t\t\treturn this._sem.runExclusive(async () => {\n\t\t\t\t\t\tconst priv = b64URLToBytes(privString)\n\t\t\t\t\t\tconst pub = await this.config.crypto.getPublicKey(priv)\n\t\t\t\t\t\tconst pubString = bytesToB64URL(pub)\n\n\t\t\t\t\t\tconst payload = await getPayload<MetadataGetPayload>({\n\t\t\t\t\t\t\tcrypto: this.config.crypto,\n\t\t\t\t\t\t\tpayload: {\n\t\t\t\t\t\t\t\tmetadataV2Key: pubString,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tconst res = await this.config.net.POST<MetadataGetRes>(\n\t\t\t\t\t\t\tthis.config.metadataNode + \"/api/v2/metadata/get\",\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tJSON.stringify(payload),\n\t\t\t\t\t\t\t(res) => new Response(res).json(),\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif (((res.data as unknown) as string) == \"Key not found\") {\n\t\t\t\t\t\t\treturn undefined\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn pub\n\t\t\t\t\t})\n\t\t\t\t}),\n\t\t\t)\n\t\t).filter(Boolean) as Uint8Array[]\n\n\t\treturn validLocations\n\t}\n\n\tasync _metadataIndexAdd (priv: Uint8Array, encryptKey: Uint8Array | undefined) {\n\t\tconst privString = bytesToB64URL(priv)\n\t\tconst encryptKeyString = encryptKey ? bytesToB64URL(encryptKey) : undefined\n\n\t\tconst metaIndexPriv = await this.config.crypto.derive(undefined, this.metadataIndexPath)\n\n\t\t// fast check\n\t\tconst doc = await this._get<MetadataIndex>(metaIndexPriv, undefined, false)\n\t\tif (doc && privString in doc.privs) {\n\t\t\treturn\n\t\t}\n\n\t\t// long set\n\t\tawait this._change<MetadataIndex>(\n\t\t\tmetaIndexPriv,\n\t\t\tundefined,\n\t\t\t(doc) => {\n\t\t\t\tif (privString in doc) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (!doc.privs) {\n\t\t\t\t\tdoc.privs = {}\n\t\t\t\t}\n\t\t\t\tif (!doc.encryptKeys) {\n\t\t\t\t\tdoc.encryptKeys = {}\n\t\t\t\t}\n\n\t\t\t\tdoc.privs[privString] = true\n\t\t\t\tif (encryptKeyString) {\n\t\t\t\t\tdoc.encryptKeys[privString] = encryptKeyString\n\t\t\t\t}\n\t\t\t},\n\t\t\tfalse,\n\t\t\tundefined,\n\t\t\ttrue,\n\t\t)\n\t}\n\n\tasync _metadataIndexRemove (priv: Uint8Array) {\n\t\tconst privString = bytesToB64URL(priv)\n\n\t\tconst metaIndexPriv = await this.config.crypto.derive(undefined, this.metadataIndexPath)\n\n\t\t// fast check\n\t\tconst doc = await this._get<MetadataIndex>(metaIndexPriv, undefined, false)\n\t\tif (doc && !(privString in doc.privs)) {\n\t\t\treturn\n\t\t}\n\n\t\t// long set\n\t\tawait this._change<MetadataIndex>(\n\t\t\tmetaIndexPriv,\n\t\t\tundefined,\n\t\t\t(doc) => {\n\t\t\t\tif (privString in doc) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tdelete doc.privs[privString]\n\t\t\t\tdelete doc.encryptKeys[privString]\n\t\t\t},\n\t\t\tfalse,\n\t\t\tundefined,\n\t\t\ttrue,\n\t\t)\n\t}\n\n\tasync change<T = unknown> (\n\t\tpath: string,\n\t\tdescription: string,\n\t\tfn: Automerge.ChangeFn<Automerge.Proxy<T>>,\n\t\tmarkCacheDirty = false,\n\t): Promise<Automerge.Doc<T>> {\n\t\t// console.log(\"change(\", path, description, fn, \")\")\n\n\t\tpath = cleanPath(path)\n\n\t\tconst priv = await this.config.crypto.derive(undefined, path)\n\t\tawait this._metadataIndexAdd(priv, undefined)\n\n\t\treturn await this._change<T>(priv, description, fn, false, undefined, markCacheDirty)\n\t}\n\n\tasync changePublic<T = unknown> (\n\t\tpriv: Uint8Array,\n\t\tdescription: string | undefined,\n\t\tfn: Automerge.ChangeFn<Automerge.Proxy<T>>,\n\t\tencryptKey: Uint8Array,\n\t\tmarkCacheDirty = false,\n\t): Promise<Automerge.Doc<T>> {\n\t\t// console.log(\"changePublic(\", priv, description, fn, encryptKey, \")\")\n\n\t\tawait this._metadataIndexAdd(priv, encryptKey)\n\n\t\treturn await this._change<T>(priv, description, fn, true, encryptKey, markCacheDirty)\n\t}\n\n\tasync _change<T = unknown> (\n\t\tpriv: Uint8Array,\n\t\tdescription: string | undefined,\n\t\tfn: Automerge.ChangeFn<Automerge.Proxy<T>>,\n\t\tisPublic: boolean,\n\t\tencryptKey?: Uint8Array,\n\t\tmarkCacheDirty = false,\n\t): Promise<Automerge.Doc<T>> {\n\t\t// console.log(\"_change(\", priv, description, fn, isPublic, encryptKey, \")\")\n\n\t\tconst pub = await this.config.crypto.getPublicKey(priv)\n\t\tconst pubString = bytesToB64URL(pub)\n\n\t\t// sync\n\t\tconst curDoc = (await this._get<T>(priv, undefined, markCacheDirty)) || Automerge.init<T>()\n\t\tthis.dags[pubString] = this.dags[pubString] || new DAG()\n\t\tconst dag = this.dags[pubString]\n\n\t\t// change\n\t\tconst newDoc = description ? Automerge.change(curDoc, description, fn) : Automerge.change(curDoc, fn)\n\n\t\t// commit\n\n\t\tconst changes = Automerge.getChanges(curDoc, newDoc)\n\n\t\tif (!changes.length) {\n\t\t\treturn curDoc\n\t\t}\n\n\t\tconst encrypted = await this.config.crypto.encrypt(encryptKey || sha256(priv), packChanges(changes))\n\t\tconst v = new DAGVertex(encrypted)\n\t\tdag.addReduced(v)\n\n\t\tconst edges = dag.parentEdges(v.id)\n\n\t\tconst payload = await getPayload<MetadataAddPayload>({\n\t\t\tcrypto: this.config.crypto,\n\t\t\tpayload: {\n\t\t\t\tisPublic,\n\t\t\t\tmetadataV2Edges: edges.map((edge) => bytesToB64URL(edge.binary)),\n\t\t\t\tmetadataV2Key: pubString,\n\t\t\t\tmetadataV2Sig: bytesToB64URL(await this.config.crypto.sign(priv, await dag.digest(v.id, sha256))),\n\t\t\t\tmetadataV2Vertex: bytesToB64URL(v.binary),\n\t\t\t},\n\t\t})\n\n\t\tawait this.config.net.POST<MetadataAddRes>(\n\t\t\tthis.config.metadataNode + \"/api/v2/metadata/add\",\n\t\t\tundefined,\n\t\t\tJSON.stringify(payload),\n\t\t\t(res) => new Response(res).json(),\n\t\t)\n\n\t\tthis.dags[pubString] = dag\n\t\tthis.cache[pubString] = {\n\t\t\tlastAccess: Date.now(),\n\t\t\tdirty: false,\n\t\t\tdoc: newDoc,\n\t\t}\n\n\t\tsetTimeout(() => {\n\t\t\tdelete this.dags[pubString]\n\t\t\tdelete this.cache[pubString]\n\t\t}, 60 * 1000)\n\n\t\treturn newDoc\n\t}\n\n\tasync get<T> (path: string, markCacheDirty = false): Promise<Automerge.Doc<T> | undefined> {\n\t\t// console.log(\"get(\", path, \")\")\n\n\t\tpath = cleanPath(path)\n\n\t\tconst priv = await this.config.crypto.derive(undefined, path)\n\t\treturn await this._get<T>(priv, undefined, markCacheDirty)\n\t}\n\n\tasync _get<T> (\n\t\tpriv: Uint8Array,\n\t\tdecryptKey?: Uint8Array,\n\t\tmarkCacheDirty = false,\n\t): Promise<Automerge.Doc<T> | undefined> {\n\t\t// console.log(\"_get(\", priv, decryptKey, \")\")\n\n\t\tconst pub = await this.config.crypto.getPublicKey(priv)\n\t\tconst pubString = bytesToB64URL(pub)\n\n\t\tconst cached = this.cache[pubString]\n\n\t\tif (markCacheDirty || !cached || cached.dirty == true) {\n\t\t\tif (this.config.logging) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"Cache: cache not used for\",\n\t\t\t\t\tpubString,\n\t\t\t\t\t\"because\",\n\t\t\t\t\t!cached ? \"item was not found in cache\" : \"cache entry was marked dirty\",\n\t\t\t\t)\n\t\t\t}\n\t\t\tconst payload = await getPayload<MetadataGetPayload>({\n\t\t\t\tcrypto: this.config.crypto,\n\t\t\t\tpayload: {\n\t\t\t\t\tmetadataV2Key: pubString,\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tconst res = await this.config.net.POST<MetadataGetRes>(\n\t\t\t\tthis.config.metadataNode + \"/api/v2/metadata/get\",\n\t\t\t\tundefined,\n\t\t\t\tJSON.stringify(payload),\n\t\t\t\t(res) => new Response(res).json(),\n\t\t\t)\n\n\t\t\tif (((res.data as unknown) as string) == \"Key not found\") {\n\t\t\t\treturn undefined\n\t\t\t}\n\n\t\t\tconst dag = DAG.fromBinary(b64URLToBytes(res.data.metadataV2))\n\t\t\tthis.dags[pubString] = dag\n\t\t}\n\t\telse {\n\t\t\tif (this.config.logging) {\n\t\t\t\tconsole.info(\"Cache: using cached value for\", pubString)\n\t\t\t}\n\n\t\t\tcached.lastAccess = Date.now()\n\n\t\t\treturn cached.doc as Automerge.Doc<T>\n\t\t}\n\n\t\tconst decrypted = await Promise.all(\n\t\t\tthis.dags[pubString].nodes.map(({ data }) => this.config.crypto.decrypt(decryptKey || sha256(priv), data)),\n\t\t)\n\t\tconst changes = decrypted.map((data) => unpackChanges(data)).flat()\n\n\t\tconst doc = Automerge.applyChanges(Automerge.init<T>(), changes)\n\t\tthis.cache[pubString] = {\n\t\t\tlastAccess: Date.now(),\n\t\t\tdirty: false,\n\t\t\tdoc,\n\t\t}\n\n\t\tsetTimeout(() => {\n\t\t\tdelete this.dags[pubString]\n\t\t\tdelete this.cache[pubString]\n\t\t}, 60 * 1000)\n\n\t\treturn doc\n\t}\n\n\tasync getPublic<T> (\n\t\tpriv: Uint8Array,\n\t\tdecryptKey: Uint8Array,\n\t\tmarkCacheDirty = false,\n\t): Promise<Automerge.Doc<T> | undefined> {\n\t\treturn await this._getPublic(priv, decryptKey)\n\t}\n\n\tasync _getPublic<T> (\n\t\tpriv: Uint8Array,\n\t\tdecryptKey: Uint8Array,\n\t\tmarkCacheDirty = false,\n\t): Promise<Automerge.Doc<T> | undefined> {\n\t\t// console.log(\"_getPublic\", priv, decryptKey, \")\")\n\n\t\tconst pub = await this.config.crypto.getPublicKey(priv)\n\t\tconst pubString = bytesToB64URL(pub)\n\n\t\tconst cached = this.cache[pubString]\n\n\t\tif (markCacheDirty || !cached || cached.dirty == true) {\n\t\t\tif (this.config.logging) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"Cache: cache not used for\",\n\t\t\t\t\tpubString,\n\t\t\t\t\t\"because\",\n\t\t\t\t\t!cached ? \"item was not found in cache\" : \"cache entry was marked dirty\",\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst res = await this.config.net.POST<MetadataGetRes>(\n\t\t\t\tthis.config.metadataNode + \"/api/v2/metadata/get-public\",\n\t\t\t\tundefined,\n\t\t\t\tJSON.stringify({\n\t\t\t\t\trequestBody: JSON.stringify({\n\t\t\t\t\t\tmetadataV2Key: pubString,\n\t\t\t\t\t\ttimestamp: Math.floor(Date.now() / 1000),\n\t\t\t\t\t}),\n\t\t\t\t}),\n\t\t\t\t(res) => new Response(res).json(),\n\t\t\t)\n\n\t\t\tconst dag = DAG.fromBinary(b64URLToBytes(res.data.metadataV2))\n\t\t\tthis.dags[pubString] = dag\n\t\t}\n\t\telse {\n\t\t\tif (this.config.logging) {\n\t\t\t\tconsole.info(\"Cache: using cached value for\", pubString)\n\t\t\t}\n\n\t\t\treturn cached.doc as Automerge.Doc<T>\n\t\t}\n\n\t\tconst decrypted = await Promise.all(\n\t\t\tthis.dags[pubString].nodes.map(({ data }) => this.config.crypto.decrypt(decryptKey, data)),\n\t\t)\n\t\tconst changes = decrypted.map((data) => unpackChanges(data)).flat()\n\n\t\tconst doc = Automerge.applyChanges(Automerge.init<T>(), changes)\n\n\t\tthis.cache[pubString] = {\n\t\t\tlastAccess: Date.now(),\n\t\t\tdirty: false,\n\t\t\tdoc,\n\t\t}\n\n\t\tsetTimeout(() => {\n\t\t\tdelete this.dags[pubString]\n\t\t\tdelete this.cache[pubString]\n\t\t}, 60 * 1000)\n\n\t\treturn doc\n\t}\n\n\tasync delete (path: string): Promise<void> {\n\t\t// console.log(\"delete(\", path, \")\")\n\n\t\tpath = cleanPath(path)\n\n\t\tconst priv = await this.config.crypto.derive(undefined, path)\n\n\t\tawait this._delete(priv)\n\t\tawait this._metadataIndexRemove(priv)\n\t}\n\n\tasync deletePublic (priv: Uint8Array): Promise<void> {\n\t\t// console.log(\"deletePublic(\", priv, \")\")\n\n\t\tawait this._delete(priv)\n\t\tawait this._metadataIndexRemove(priv)\n\t}\n\n\tasync _delete (priv: Uint8Array): Promise<void> {\n\t\t// console.log(\"_delete(\", priv, \")\")\n\n\t\tconst pub = await this.config.crypto.getPublicKey(priv)\n\t\tconst pubString = bytesToB64URL(pub)\n\n\t\tconst payload = await getPayload<MetadataDeletePayload>({\n\t\t\tcrypto: this.config.crypto,\n\t\t\tpayload: {\n\t\t\t\tmetadataV2Key: pubString,\n\t\t\t},\n\t\t})\n\n\t\tawait this.config.net.POST<MetadataDeleteRes>(\n\t\t\tthis.config.metadataNode + \"/api/v2/metadata/delete\",\n\t\t\tundefined,\n\t\t\tJSON.stringify(payload),\n\t\t\t(res) => new Response(res).json(),\n\t\t)\n\n\t\tdelete this.dags[pubString]\n\t\tdelete this.cache[pubString]\n\t}\n}\n","const hashToPath = (h: string, { prefix = false }: { prefix?: boolean } = {}) => {\n\tif (h.length % 4) {\n\t\tthrow new Error(\"hash length must be multiple of two bytes\")\n\t}\n\n\treturn (prefix ? \"m/\" : \"\") + h.match(/.{1,4}/g).map(p => parseInt(p, 16)).join(\"'/\") + \"'\"\n}\n\nexport { hashToPath }\n","import { downloadFile } from \"../v0/downloadFile\";\nimport { generateSubHDKey } from \"../v0/generateSubHDKey\";\nimport { getAccountInfo } from \"../v0/getAccountInfo\";\nimport { getFolderHDKey } from \"../v0/getFolderHDKey\";\nimport { getFolderLocation } from \"../v0/getFolderLocation\";\nimport { getHandle } from \"../v0/getHandle\";\nimport { isPaid } from \"../v0/isPaid\";\nimport { register } from \"../v0/register\";\n\nimport { buildFullTree } from \"./buildFullTree\"\nimport { createFolder } from \"./createFolder\";\nimport { createFolderMeta } from \"./createFolderMeta\";\nimport { createMetaQueue } from \"./createMetaQueue\";\nimport { deleteFile } from \"./deleteFile\";\nimport { deleteFolder } from \"./deleteFolder\";\nimport { deleteFolderMeta } from \"./deleteFolderMeta\";\nimport { deleteVersion } from \"./deleteVersion\";\nimport { getFolderMeta } from \"./getFolderMeta\";\nimport { isExpired } from \"./isExpired\";\nimport { login } from \"./login\";\nimport { moveFile, MoveFileArgs } from \"./moveFile\";\nimport { moveFolder, MoveFolderArgs } from \"./moveFolder\";\nimport { renameFile, RenameFileArgs } from \"./renameFile\";\nimport { renameFolder, RenameFolderArgs } from \"./renameFolder\";\nimport { renewAccount } from \"./renewAccount\"\nimport { setFolderMeta } from \"./setFolderMeta\";\nimport { upgradeAccount } from \"./upgradeAccount\";\nimport { uploadFile } from \"./uploadFile\";\n\nexport {\n\tdownloadFile,\n\tgenerateSubHDKey,\n\tgetAccountInfo,\n\tgetFolderHDKey,\n\tgetFolderLocation,\n\tgetHandle,\n\tisPaid,\n\tregister,\n\n\tbuildFullTree,\n\tcreateFolder,\n\tcreateFolderMeta,\n\tcreateMetaQueue,\n\tdeleteFile,\n\tdeleteFolder,\n\tdeleteFolderMeta,\n\tdeleteVersion,\n\tgetFolderMeta,\n\tisExpired,\n\tlogin,\n\tmoveFile,\n\tMoveFileArgs,\n\tmoveFolder,\n\tMoveFolderArgs,\n\trenameFile,\n\tRenameFileArgs,\n\trenameFolder,\n\tRenameFolderArgs,\n\trenewAccount,\n\tsetFolderMeta,\n\tupgradeAccount,\n\tuploadFile\n}\n\n/**\n * internal API v1\n *\n * @internal\n */\nconst v1 = {\n\tdownloadFile,\n\tgenerateSubHDKey,\n\tgetAccountInfo,\n\tgetFolderHDKey,\n\tgetFolderLocation,\n\tgetHandle,\n\tisPaid,\n\tregister,\n\n\tbuildFullTree,\n\tcreateFolder,\n\tcreateFolderMeta,\n\tcreateMetaQueue,\n\tdeleteFile,\n\tdeleteFolder,\n\tdeleteFolderMeta,\n\tdeleteVersion,\n\tgetFolderMeta,\n\tisExpired,\n\tlogin,\n\tmoveFile,\n\tmoveFolder,\n\trenameFile,\n\trenameFolder,\n\trenewAccount,\n\tsetFolderMeta,\n\tupgradeAccount,\n\tuploadFile\n}\n\nexport default v1\n","import HDKey from \"hdkey/lib/hdkey\"\n\nimport { CryptoMiddleware } from \"@opacity/middleware\"\nimport { hashToPath, pathHash } from \"@opacity/util/src/derive\"\n\nexport type WebAccountMiddlewareArgs = {\n\tasymmetricKey?: Uint8Array\n\tsymmetricKey?: Uint8Array\n}\n\nexport class WebAccountMiddleware implements CryptoMiddleware {\n\tasymmetricKey?: Uint8Array\n\tsymmetricKey?: Uint8Array\n\n\tconstructor ({ symmetricKey, asymmetricKey }: WebAccountMiddlewareArgs = {}) {\n\t\tthis.asymmetricKey = asymmetricKey\n\t\tthis.symmetricKey = symmetricKey\n\t}\n\n\tasync getRandomValues (size: number): Promise<Uint8Array> {\n\t\treturn crypto.getRandomValues(new Uint8Array(size))\n\t}\n\n\tasync getPublicKey (k: Uint8Array | undefined = this.asymmetricKey): Promise<Uint8Array> {\n\t\tif (k == undefined) {\n\t\t\tthrow new ReferenceError(\"WebAccountMiddleware: key must not be undefined\")\n\t\t}\n\n\t\tconst hd = new HDKey()\n\t\thd.privateKey = Buffer.from(k.slice(0, 32))\n\t\thd.chainCode = Buffer.from(k.slice(32))\n\n\t\treturn hd.publicKey\n\t}\n\n\tasync derive (k: Uint8Array | undefined = this.asymmetricKey, p: string): Promise<Uint8Array> {\n\t\tif (k == undefined) {\n\t\t\tthrow new ReferenceError(\"WebAccountMiddleware: key must not be undefined\")\n\t\t}\n\n\t\tconst hd = new HDKey()\n\t\thd.privateKey = Buffer.from(k.slice(0, 32))\n\t\thd.chainCode = Buffer.from(k.slice(32))\n\n\t\tconst child = hd.derive(\"m/\" + hashToPath(pathHash(p)))\n\n\t\treturn new Uint8Array(Array.from(child.privateKey).concat(Array.from(child.chainCode)))\n\t}\n\n\tasync sign (k: Uint8Array | undefined = this.asymmetricKey, d: Uint8Array): Promise<Uint8Array> {\n\t\tif (k == undefined) {\n\t\t\tthrow new ReferenceError(\"WebAccountMiddleware: key must not be undefined\")\n\t\t}\n\n\t\tconst hd = new HDKey()\n\t\thd.privateKey = Buffer.from(k.slice(0, 32))\n\t\thd.chainCode = Buffer.from(k.slice(32))\n\n\t\tconst sig = hd.sign(Buffer.from(d))\n\n\t\treturn sig\n\t}\n\n\tasync generateSymmetricKey (): Promise<Uint8Array> {\n\t\tconst key = await crypto.subtle.exportKey(\n\t\t\t\"raw\",\n\t\t\tawait crypto.subtle.generateKey({ name: \"AES-GCM\", length: 256 }, true, [\"encrypt\", \"decrypt\"]),\n\t\t)\n\t\treturn new Uint8Array(key)\n\t}\n\n\tasync encrypt (k: Uint8Array | undefined = this.symmetricKey, d: Uint8Array): Promise<Uint8Array> {\n\t\tif (k == undefined) {\n\t\t\tthrow new ReferenceError(\"WebAccountMiddleware: key must not be undefined\")\n\t\t}\n\n\t\tconst key = await crypto.subtle.importKey(\"raw\", k, \"AES-GCM\", false, [\"encrypt\"])\n\t\tconst iv = crypto.getRandomValues(new Uint8Array(16))\n\t\tconst encrypted = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv, tagLength: 128 }, key, d))\n\t\treturn new Uint8Array([...encrypted, ...iv])\n\t}\n\n\tasync decrypt (k: Uint8Array | undefined = this.symmetricKey, ct: Uint8Array): Promise<Uint8Array> {\n\t\tif (k == undefined) {\n\t\t\tthrow new ReferenceError(\"WebAccountMiddleware: key must not be undefined\")\n\t\t}\n\n\t\tconst key = await crypto.subtle.importKey(\"raw\", k, \"AES-GCM\", false, [\"decrypt\"])\n\t\treturn new Uint8Array(await crypto.subtle.decrypt({ name: \"AES-GCM\", iv: ct.slice(-16) }, key, ct.slice(0, -16)))\n\t}\n}\n","import {\n\tNetworkMiddleware,\n\tNetworkMiddlewareFunction,\n\tNetworkMiddlewareMapReturn,\n\tNetworkMiddlewareResponse,\n} from \"@opacity/middleware\"\n\nconst fetchAdapter = async <T>(\n\tmethod: string,\n\taddress: string,\n\theaders: HeadersInit | undefined,\n\tbody: BodyInit | undefined,\n\tmapReturn: NetworkMiddlewareMapReturn<T>,\n): Promise<NetworkMiddlewareResponse<T>> => {\n\tconst res = await fetch(address, { method, body, headers })\n\n\treturn {\n\t\theaders: res.headers,\n\t\tdata: await mapReturn(res.body || undefined),\n\t\tok: res.ok,\n\t\tredirected: res.redirected,\n\t\tstatus: res.status,\n\t\tstatusText: res.statusText,\n\t\turl: address,\n\t}\n}\n\nexport class WebNetworkMiddleware implements NetworkMiddleware {\n\tGET: NetworkMiddlewareFunction<undefined> = async (\n\t\taddress: string,\n\t\theaders?: HeadersInit,\n\t\tbody?: undefined,\n\t\tmapReturn = async (b: ReadableStream<Uint8Array> | undefined) =>\n\t\t\tnew Uint8Array(await new Response(b).arrayBuffer()),\n\t) => {\n\t\treturn await fetchAdapter(\"GET\", address, headers, body, mapReturn)\n\t}\n\n\tasync POST<T> (\n\t\taddress: string,\n\t\theaders?: HeadersInit,\n\t\tbody?: BodyInit,\n\t\tmapReturn = async (b: ReadableStream<Uint8Array> | undefined) =>\n\t\t\tnew Uint8Array(await new Response(b).arrayBuffer()),\n\t) {\n\t\treturn await fetchAdapter(\"POST\", address, headers, body, mapReturn)\n\t}\n}\n","import { FileMeta } from \"./filemeta\"\nimport { EventListenerOrEventListenerObject } from \"@opacity/util/src/events\"\n\nexport enum DownloadEvents {\n\tMETADATA = \"metadata\",\n\tSTART = \"start\",\n\tFINISH = \"finish\",\n\tPROGRESS = \"progress\",\n}\n\ntype DownloadMetadataEventData = { metadata: FileMeta }\nexport class DownloadMetadataEvent extends CustomEvent<DownloadMetadataEventData> {\n\tconstructor (data: DownloadMetadataEventData) {\n\t\tsuper(DownloadEvents.METADATA, { detail: data })\n\t}\n}\ntype DownloadStartedEventData = { time: number }\nexport class DownloadStartedEvent extends CustomEvent<DownloadStartedEventData> {\n\tconstructor (data: DownloadStartedEventData) {\n\t\tsuper(DownloadEvents.START, { detail: data })\n\t}\n}\ntype DownloadFinishedEventData = { start: number; end: number; duration: number; realDuration: number }\nexport class DownloadFinishedEvent extends CustomEvent<DownloadFinishedEventData> {\n\tconstructor (data: DownloadFinishedEventData) {\n\t\tsuper(DownloadEvents.FINISH, { detail: data })\n\t}\n}\ntype DownloadProgressEventData = { progress: number }\nexport class DownloadProgressEvent extends CustomEvent<DownloadProgressEventData> {\n\tconstructor (data: DownloadProgressEventData) {\n\t\tsuper(DownloadEvents.PROGRESS, { detail: data })\n\t}\n}\n\nexport interface IDownloadEvents {\n\taddEventListener(\n\t\ttype: DownloadEvents,\n\t\tlistener: EventListener | EventListenerObject | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n\n\taddEventListener(\n\t\ttype: DownloadEvents.METADATA,\n\t\tlistener: EventListenerOrEventListenerObject<DownloadMetadataEvent> | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n\taddEventListener(\n\t\ttype: DownloadEvents.START,\n\t\tlistener: EventListenerOrEventListenerObject<DownloadStartedEvent> | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n\taddEventListener(\n\t\ttype: DownloadEvents.FINISH,\n\t\tlistener: EventListenerOrEventListenerObject<DownloadFinishedEvent> | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n\taddEventListener(\n\t\ttype: DownloadEvents.PROGRESS,\n\t\tlistener: EventListenerOrEventListenerObject<DownloadProgressEvent> | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n}\n\nexport enum UploadEvents {\n\tMETADATA = \"metadata\",\n\tSTART = \"start\",\n\tFINISH = \"finish\",\n\tPROGRESS = \"progress\",\n}\n\ntype UploadMetadataEventData = { metadata: FileMeta }\nexport class UploadMetadataEvent extends CustomEvent<UploadMetadataEventData> {\n\tconstructor (data: UploadMetadataEventData) {\n\t\tsuper(UploadEvents.METADATA, { detail: data })\n\t}\n}\ntype UploadStartedEventData = { time: number }\nexport class UploadStartedEvent extends CustomEvent<UploadStartedEventData> {\n\tconstructor (data: UploadStartedEventData) {\n\t\tsuper(UploadEvents.START, { detail: data })\n\t}\n}\ntype UploadFinishedEventData = { start: number; end: number; duration: number; realDuration: number }\nexport class UploadFinishedEvent extends CustomEvent<UploadFinishedEventData> {\n\tconstructor (data: UploadFinishedEventData) {\n\t\tsuper(UploadEvents.FINISH, { detail: data })\n\t}\n}\ntype UploadProgressEventData = { progress: number }\nexport class UploadProgressEvent extends CustomEvent<UploadProgressEventData> {\n\tconstructor (data: UploadProgressEventData) {\n\t\tsuper(UploadEvents.PROGRESS, { detail: data })\n\t}\n}\n\nexport interface IUploadEvents {\n\taddEventListener(\n\t\ttype: UploadEvents,\n\t\tlistener: EventListener | EventListenerObject | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n\n\taddEventListener(\n\t\ttype: UploadEvents.METADATA,\n\t\tlistener: EventListenerOrEventListenerObject<UploadMetadataEvent> | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n\taddEventListener(\n\t\ttype: UploadEvents.START,\n\t\tlistener: EventListenerOrEventListenerObject<UploadStartedEvent> | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n\taddEventListener(\n\t\ttype: UploadEvents.FINISH,\n\t\tlistener: EventListenerOrEventListenerObject<UploadFinishedEvent> | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n\taddEventListener(\n\t\ttype: UploadEvents.PROGRESS,\n\t\tlistener: EventListenerOrEventListenerObject<UploadProgressEvent> | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n}\n\nexport enum FileSystemObjectEvents {\n\tDELETE = \"delete\",\n}\n\ntype FileSystemObjectDeleteEventData = {}\nexport class FileSystemObjectDeleteEvent extends CustomEvent<FileSystemObjectDeleteEventData> {\n\tconstructor (data: FileSystemObjectDeleteEventData) {\n\t\tsuper(FileSystemObjectEvents.DELETE, { detail: data })\n\t}\n}\n\nexport interface IFileSystemObjectEvents {\n\taddEventListener(\n\t\ttype: FileSystemObjectEvents,\n\t\tlistener: EventListener | EventListenerObject | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n\n\taddEventListener(\n\t\ttype: FileSystemObjectEvents.DELETE,\n\t\tlistener: EventListenerOrEventListenerObject<FileSystemObjectDeleteEvent> | null,\n\t\toptions?: boolean | AddEventListenerOptions | undefined,\n\t): void\n}\n","import { CryptoMiddleware } from \"@opacity/middleware\"\n\nexport const serializeEncrypted = async <T>(\n\tcrypto: CryptoMiddleware,\n\tbytes: Uint8Array,\n\tkey: Uint8Array,\n): Promise<T> => {\n\tconst v = await crypto.decrypt(key, bytes)\n\tconst s = new TextDecoder(\"utf-8\").decode(v)\n\n\treturn JSON.parse(s) as T\n}\n","export const arraysEqual = <T>(a: ArrayLike<T>, b: ArrayLike<T>) => {\n\tfor (let i = a.length; -1 < i; i -= 1) {\n\t\tif (a[i] !== b[i]) return false\n\t}\n\treturn true\n}\n","import { posix } from \"path-browserify\"\n\nexport const cleanPath = (path: string) => {\n\tif (path[0] != posix.sep) {\n\t\tthrow new Error(\"Path must be absolute\")\n\t}\n\n\treturn (\n\t\t\"/\" +\n\t\tposix\n\t\t\t.normalize(path)\n\t\t\t.split(posix.sep)\n\t\t\t.filter((d) => d != \"\")\n\t\t\t.join(posix.sep)\n\t)\n}\n\nexport const isPathChild = (parent: string, other: string) => {\n\tconst rel = posix.relative(parent, other)\n\n\tif (rel != \"\" && rel[0] != \".\" && rel.split(posix.sep).length == 1) {\n\t\treturn true\n\t}\n\n\treturn false\n}\n","import { fromMasterSeed } from \"hdkey/lib/hdkey\"\nimport { generateMnemonic, mnemonicToSeed, entropyToMnemonic } from \"bip39\"\n\nimport { hashToPath, nameHash } from \"./derive\"\nimport { bytesToHex } from \"./hex\"\n\n/**\n * HD derive path for account handle\n */\nexport const ACCOUNT_DERIVE_PATH = \"m/43'/60'/1775'/0'/\" + hashToPath(nameHash(\"opacity.io\"))\n\nexport const createMnemonic = async (): Promise<string[]> => {\n\treturn generateMnemonic().split(\" \")\n}\n\nexport const mnemonicToHandle = async (mnemonic: string[]): Promise<Uint8Array> => {\n\tconst seed = await mnemonicToSeed(mnemonic.join(\" \"))\n\tconst hd = fromMasterSeed(seed).derive(ACCOUNT_DERIVE_PATH)\n\n\treturn new Uint8Array(Array.from(hd.privateKey).concat(Array.from(hd.chainCode)))\n}\n\nexport const entropyToKey = async (entropy: Uint8Array) => {\n\tconst hex = bytesToHex(entropy)\n\tconst mnemonic = entropyToMnemonic(hex)\n\tconst seed = await mnemonicToSeed(mnemonic)\n\tconst hd = fromMasterSeed(seed)\n\treturn new Uint8Array(hd.privateKey)\n}\n","export type ArrayLikeWritable<T> = {\n\treadonly length: number\n\t[n: number]: T\n}\n\nexport const arrayMerge = <T extends ArrayLikeWritable<unknown>>(...arr: T[]) => {\n\tif (arr.length == 0) {\n\t\treturn ([] as unknown) as T\n\t}\n\n\tconst l = arr.reduce((acc, cur) => acc + cur.length, 0)\n\n\tconst out: typeof arr[ 0 ] = new (arr[0].constructor as any)(l) as T\n\n\tlet i = 0\n\tfor (let a of arr) {\n\t\tfor (let j = 0; j < a.length; j++) {\n\t\t\tout[i] = a[j]\n\t\t\ti++\n\t\t}\n\t}\n\n\treturn out\n}\n","import { readUInt32BE, uint32ToUint8BE } from \"@opacity/util/src/uint\"\n\nexport class CyclicReferenceError extends Error {\n\tconstructor (id: number, stack: number[]) {\n\t\tsuper(`DAG: Cyclic reference detected ${id} in ${JSON.stringify(stack)}`)\n\t}\n}\n\nexport class BinarySerializationError extends Error {\n\tconstructor (why: string, data: Uint8Array) {\n\t\tsuper(`DAG: Invalid binary ${data} because of \"${why}\"`)\n\t}\n}\n\nexport class VertexExistsError extends Error {\n\tconstructor (id: number) {\n\t\tsuper(`DAG: Vertex id ${id} already exists in dag`)\n\t}\n}\n\nexport class EdgeExistsError extends Error {\n\tconstructor (edge: DAGEdge) {\n\t\tsuper(`DAG: Edge already exists ${edge.child} -> ${edge.parent}`)\n\t}\n}\nexport class VertexNotFoundError extends Error {\n\tconstructor (id: number, stack: DAGVertex[]) {\n\t\tsuper(`DAG: Vertex ${id} not found in in ${JSON.stringify(stack)}`)\n\t}\n}\n\nenum DAGBinaryTypes {\n\tDAG,\n\tVERTEX,\n\tEDGE,\n}\n\nenum DAGDigestTypes {\n\tLEAF,\n\tBRANCH,\n}\n\nconst checkLength = (b: Uint8Array, actual: number) => {\n\tif (actual > b.length) {\n\t\tthrow new BinarySerializationError(\"invalid length\", b)\n\t}\n}\n\nexport class DAG {\n\tstatic fromBinary (b: Uint8Array): DAG {\n\t\tconst d = new DAG()\n\t\tlet i = 0\n\n\t\tcheckLength(b, i + 1)\n\t\tconst type = b[0]\n\t\ti += 1\n\n\t\tif (type != DAGBinaryTypes.DAG) {\n\t\t\tthrow new BinarySerializationError(`invalid type, expected ${DAGBinaryTypes.DAG}, got ${type}`, b)\n\t\t}\n\n\t\tcheckLength(b, i + 4)\n\t\tconst nodesLength = readUInt32BE(b, i)\n\t\ti += 4\n\n\t\tfor (let n = 0; n < nodesLength; n++) {\n\t\t\tcheckLength(b, i + 4)\n\t\t\tconst l = readUInt32BE(b, i)\n\t\t\ti += 4\n\t\t\tcheckLength(b, i + l)\n\t\t\tconst nbin = b.slice(i, i + l)\n\t\t\ti += l\n\t\t\td.add(DAGVertex.fromBinary(nbin))\n\t\t}\n\n\t\tcheckLength(b, i + 4)\n\t\tconst edgesLength = readUInt32BE(b, i)\n\t\ti += 4\n\n\t\tfor (let e = 0; e < edgesLength; e++) {\n\t\t\tcheckLength(b, i + 4)\n\t\t\tconst l = readUInt32BE(b, i)\n\t\t\ti += 4\n\t\t\tcheckLength(b, i + l)\n\t\t\tconst ebin = b.slice(i, i + l)\n\t\t\ti += l\n\t\t\td.addEdge(DAGEdge.fromBinary(ebin))\n\t\t}\n\n\t\treturn d\n\t}\n\n\tget binary (): Uint8Array {\n\t\treturn new Uint8Array(\n\t\t\t([] as number[]).concat(\n\t\t\t\tArray.from(uint32ToUint8BE(this.nodes.length)),\n\t\t\t\tthis.nodes\n\t\t\t\t\t.map((node) => Array.from(uint32ToUint8BE(node.binary.length)).concat(Array.from(node.binary)))\n\t\t\t\t\t.flat(),\n\t\t\t\tArray.from(uint32ToUint8BE(this.edges.length)),\n\t\t\t\tthis.edges\n\t\t\t\t\t.map((edge) => Array.from(uint32ToUint8BE(edge.binary.length)).concat(Array.from(edge.binary)))\n\t\t\t\t\t.flat(),\n\t\t\t),\n\t\t)\n\t}\n\n\tnodes: DAGVertex[] = []\n\tedges: DAGEdge[] = []\n\tsinks: number[] = []\n\n\tclone () {\n\t\treturn DAG.fromBinary(this.binary)\n\t}\n\n\tadd (node: DAGVertex) {\n\t\tif (this.nodes.find(({ id }) => id == node.id)) {\n\t\t\tconsole.warn(new VertexExistsError(node.id))\n\t\t\treturn\n\t\t}\n\n\t\tthis.nodes.push(node)\n\t\tthis.sinks.push(node.id)\n\t}\n\n\taddReduced (node: DAGVertex) {\n\t\tfor (let sink of this.sinks.slice()) {\n\t\t\tthis.addEdge(new DAGEdge(node.id, sink))\n\t\t}\n\n\t\tthis.add(node)\n\t}\n\n\taddEdge (edge: DAGEdge) {\n\t\tif (this.edges.find(({ child, parent }) => child == edge.child && parent == edge.parent)) {\n\t\t\tconsole.warn(new EdgeExistsError(edge))\n\n\t\t\treturn\n\t\t}\n\n\t\tthis.edges.push(edge)\n\n\t\ttry {\n\t\t\tthis.dependencies(edge.child)\n\t\t} catch (err) {\n\t\t\tthis.edges.pop()\n\n\t\t\tthrow err\n\t\t}\n\n\t\tconst sinkIndex = this.sinks.findIndex((sink) => sink == edge.parent)\n\n\t\tif (sinkIndex != -1) {\n\t\t\tthis.sinks.splice(sinkIndex, 1)\n\t\t}\n\t}\n\n\tparentEdges (id: number): DAGEdge[] {\n\t\treturn this.edges.filter(({ child }) => child == id)\n\t}\n\n\tdepth (id: number): number {\n\t\tconst parents = this.parentEdges(id)\n\t\t\t.map(({ parent }) => parent)\n\t\t\t.sort((a, b) => a - b)\n\n\t\tif (parents.length) {\n\t\t\treturn (1 +\n\t\t\t\tMath.max.apply(\n\t\t\t\t\tundefined,\n\t\t\t\t\tparents.map((to) => this.depth(to)),\n\t\t\t\t)) as number\n\t\t}\n\n\t\treturn 0\n\t}\n\n\tdependencies (id: number, seen: number[] = []): number[] {\n\t\tif (seen.includes(id)) {\n\t\t\tthrow new CyclicReferenceError(id, seen)\n\t\t}\n\n\t\tconst parents = this.parentEdges(id)\n\t\t\t.map(({ parent }) => parent)\n\t\t\t.sort((a, b) => a - b)\n\n\t\tconst newSeen: number[] = ([] as number[]).concat(seen, [id])\n\n\t\treturn ([] as number[]).concat(parents, parents.map((to) => this.dependencies(to, newSeen)).flat())\n\t}\n\n\tasync digest (id: number, hash: (d: Uint8Array) => Uint8Array | Promise<Uint8Array>): Promise<Uint8Array> {\n\t\tif (!id) {\n\t\t\tconst parents = this.sinks.sort((a, b) => a - b)\n\n\t\t\tconst hashes = await Promise.all(\n\t\t\t\tparents.map(async (parent) => [DAGDigestTypes.BRANCH].concat(Array.from(await this.digest(parent, hash)))),\n\t\t\t)\n\t\t\tconst data = new Uint8Array(([] as number[]).concat(...hashes))\n\n\t\t\treturn hash(data)\n\t\t}\n\n\t\tconst node = this.nodes.find((node) => id == node.id)\n\n\t\tif (!node) {\n\t\t\tthrow new VertexNotFoundError(id, this.nodes)\n\t\t}\n\n\t\tconst leaf = [DAGDigestTypes.LEAF].concat(Array.from(await hash(node.binary)))\n\t\tconst parents = this.parentEdges(id)\n\t\t\t.map(({ parent }) => parent)\n\t\t\t.sort((a, b) => a - b)\n\n\t\tif (!parents.length) {\n\t\t\treturn hash(new Uint8Array(leaf))\n\t\t}\n\n\t\tconst branches = await Promise.all(\n\t\t\tparents.map(async (parent) => [DAGDigestTypes.BRANCH].concat(Array.from(await this.digest(parent, hash)))),\n\t\t)\n\t\tconst data = new Uint8Array(([] as number[]).concat(Array.from(leaf), branches.flat()))\n\n\t\treturn hash(data)\n\t}\n}\n\nexport class DAGEdge {\n\tstatic fromBinary (b: Uint8Array): DAGEdge {\n\t\tlet i = 0\n\n\t\tcheckLength(b, i)\n\t\tconst type = b[i]\n\t\ti += 1\n\n\t\tif (type != DAGBinaryTypes.EDGE) {\n\t\t\tthrow new BinarySerializationError(`invalid type, expected ${DAGBinaryTypes.EDGE}, got ${type}`, b)\n\t\t}\n\n\t\tcheckLength(b, i + 4)\n\t\tconst from = readUInt32BE(b, i)\n\t\ti += 4\n\t\tcheckLength(b, i + 4)\n\t\tconst to = readUInt32BE(b, i)\n\t\ti += 4\n\n\t\treturn new DAGEdge(from, to)\n\t}\n\n\tget binary (): Uint8Array {\n\t\treturn new Uint8Array(\n\t\t\t([] as number[]).concat(\n\t\t\t\t// 1\n\t\t\t\t[DAGBinaryTypes.EDGE],\n\t\t\t\t// 4\n\t\t\t\tArray.from(uint32ToUint8BE(this.child)),\n\t\t\t\t//\n\t\t\t\tArray.from(uint32ToUint8BE(this.parent)),\n\t\t\t),\n\t\t)\n\t}\n\n\tchild: number\n\tparent: number\n\n\tconstructor (child: number, parent: number) {\n\t\tthis.child = child\n\t\tthis.parent = parent\n\t}\n}\n\nexport class DAGVertex {\n\tstatic fromBinary (b: Uint8Array): DAGVertex {\n\t\tlet i = 0\n\n\t\tcheckLength(b, i)\n\t\tconst type = b[i]\n\t\ti += 1\n\n\t\tif (type != DAGBinaryTypes.VERTEX) {\n\t\t\tthrow new BinarySerializationError(`invalid type, expected ${DAGBinaryTypes.VERTEX}, got ${type}`, b)\n\t\t}\n\n\t\tcheckLength(b, i + 4)\n\t\tconst id = readUInt32BE(b, i)\n\t\ti += 4\n\n\t\tcheckLength(b, i + 4)\n\t\tconst dataLength = readUInt32BE(b, i)\n\t\ti += 4\n\t\tcheckLength(b, i + dataLength)\n\t\tconst data = b.slice(i, i + dataLength)\n\t\ti += dataLength\n\n\t\tif (i != b.length) {\n\t\t\tthrow new BinarySerializationError(\"invalid length\", b)\n\t\t}\n\n\t\tconst node = new DAGVertex(data)\n\t\tnode.id = id\n\n\t\treturn node\n\t}\n\n\tget binary (): Uint8Array {\n\t\treturn new Uint8Array(\n\t\t\t([] as number[]).concat(\n\t\t\t\t// 1\n\t\t\t\t[DAGBinaryTypes.VERTEX],\n\t\t\t\t// 4\n\t\t\t\tArray.from(uint32ToUint8BE(this.id)),\n\t\t\t\t// 4\n\t\t\t\tArray.from(uint32ToUint8BE(this.data.length)),\n\t\t\t\t// this.data.length\n\t\t\t\tArray.from(this.data),\n\t\t\t),\n\t\t)\n\t}\n\n\t// random uint32 not 0\n\tid = Math.floor(Math.random() * (2 ** 32 - 1)) + 1\n\tdata: Uint8Array\n\n\tconstructor (data: Uint8Array) {\n\t\tthis.data = data\n\t}\n}\n","export const readUInt32BE = (arr: Uint8Array, offset: number) => {\n\treturn arr.slice(offset, offset + 4).reduce((acc, n, i) => acc + n * 2 ** ((3 - i) * 8), 0)\n}\n\nexport const uint32ToUint8BE = (n: number) => {\n\treturn new Uint8Array([\n\t\t(((n & 0xff000000) >> 24) + 0x0100) & 0xff,\n\t\t(n & 0x00ff0000) >> 16,\n\t\t(n & 0x0000ff00) >> 8,\n\t\tn & 0x000000ff,\n\t])\n}\n\nexport const uint16ToUint8BE = (n: number) => {\n\treturn new Uint8Array([(n & 0xff00) >> 8, n & 0x00ff])\n}\n","import Download from \"../../../../download\";\n\nimport { MasterHandle } from \"../../../../account\";\n\nconst downloadFile = (masterHandle: MasterHandle, handle: string) => {\n\treturn new Download(handle, masterHandle.downloadOpts);\n}\n\nexport { downloadFile }","import { hash } from \"../../../../core/hashing\";\nimport { hashToPath } from \"../../../../utils/hashToPath\";\n\nimport { MasterHandle, HDKey } from \"../../../../account\";\n\nconst generateSubHDKey = (masterHandle: MasterHandle, pathString: string): HDKey => {\n\tconst path = hashToPath(hash(pathString), { prefix: true })\n\n\treturn masterHandle.derive(path)\n}\n\nexport { generateSubHDKey }\n","import { checkPaymentStatus } from \"../../../../core/requests/checkPaymentStatus\";\n\nimport { MasterHandle } from \"../../../../account\";\n\nconst getAccountInfo = async (masterHandle: MasterHandle) => (\n\t(await checkPaymentStatus(masterHandle.uploadOpts.endpoint, masterHandle)).data.account\n)\n\nexport { getAccountInfo }\n","import { MasterHandle } from \"../../../../account\";\nimport { generateSubHDKey } from \"./generateSubHDKey\";\n\nimport { cleanPath } from \"../../../../utils/cleanPath\";\n\nconst getFolderHDKey = (masterHandle: MasterHandle, dir: string) => {\n\tdir = cleanPath(dir)\n\n\treturn generateSubHDKey(masterHandle, \"folder: \" + dir);\n}\n\nexport { getFolderHDKey }\n","import { MasterHandle } from \"../../../../account\";\nimport { hash } from \"../../../../core/hashing\";\n\nimport { cleanPath } from \"../../../../utils/cleanPath\";\n\nconst getFolderLocation = (masterHandle: MasterHandle, dir: string) => {\n\tdir = cleanPath(dir)\n\n\treturn hash(masterHandle.getFolderHDKey(dir).publicKey.toString(\"hex\"));\n}\n\nexport { getFolderLocation }\n","import { MasterHandle } from \"../../../../account\";\n\nconst getHandle = (masterHandle: MasterHandle) => {\n\treturn masterHandle.privateKey.toString(\"hex\") + masterHandle.chainCode.toString(\"hex\")\n}\n\nexport { getHandle }\n","import { checkPaymentStatus } from \"../../../../core/requests/checkPaymentStatus\";\nimport { MasterHandle } from \"../../../../account\";\n\nconst isPaid = async (masterHandle: MasterHandle) => {\n\ttry {\n\t\tconst accountInfoResponse = await checkPaymentStatus(masterHandle.uploadOpts.endpoint, masterHandle)\n\n\t\treturn accountInfoResponse.data.paymentStatus == \"paid\"\n\t} catch {\n\t\treturn false\n\t}\n}\n\nexport { isPaid }\n","import { checkPaymentStatus } from \"../../../../core/requests/checkPaymentStatus\";\nimport { createAccount } from \"../../../../core/requests/createAccount\";\n\nimport { MasterHandle } from \"../../../../account\";\n\nconst register = async (masterHandle: MasterHandle, duration?: number, limit?: number) => {\n\tif (await masterHandle.isPaid()) {\n\t\treturn {\n\t\t\tdata: { invoice: { cost: 0, ethAddress: \"0x0\" } },\n\t\t\twaitForPayment: async () => ({ data: (await checkPaymentStatus(masterHandle.uploadOpts.endpoint, masterHandle)).data })\n\t\t}\n\t}\n\n\tconst createAccountResponse = await createAccount(masterHandle.uploadOpts.endpoint, masterHandle, masterHandle.getFolderLocation(\"/\"), duration, limit)\n\n\treturn {\n\t\tdata: createAccountResponse.data,\n\t\twaitForPayment: () => new Promise(resolve => {\n\t\t\tconst interval = setInterval(async () => {\n\t\t\t\t// don't perform run if it takes more than 5 seconds for response\n\t\t\t\tconst time = Date.now()\n\t\t\t\tif (await masterHandle.isPaid() && time + 5 * 1000 > Date.now()) {\n\t\t\t\t\tclearInterval(interval)\n\n\t\t\t\t\tawait masterHandle.login()\n\n\t\t\t\t\tresolve({ data: (await checkPaymentStatus(masterHandle.uploadOpts.endpoint, masterHandle)).data })\n\t\t\t\t}\n\t\t\t}, 10 * 1000)\n\t\t})\n\t}\n}\n\nexport { register }\n","import { MasterHandle } from \"../../../../account\";\nimport { FolderMeta } from \"../../folder-meta\";\n\nimport { getFolderMeta } from \"./getFolderMeta\";\n\nimport { posix } from \"path-browserify\";\nimport { cleanPath } from \"../../../../utils/cleanPath\";\n\nconst buildFullTree = async (masterHandle: MasterHandle, dir = \"/\") => {\n\tdir = cleanPath(dir)\n\n\tconst tree: { [key: string]: FolderMeta } = {}\n\n\ttree[dir] = await getFolderMeta(masterHandle, dir)\n\n\tawait Promise.all(tree[dir].folders.map(async folder => {\n\t\tObject.assign(tree, await buildFullTree(masterHandle, posix.join(dir, folder.name)))\n\t}))\n\n\treturn tree\n}\n\nexport { buildFullTree }\n","import { MasterHandle } from \"../../../../account\"\nimport { FolderEntryMeta } from \"../../../../core/account/folder-entry\"\nimport { FolderMeta } from \"../../../../core/account/folder-meta\"\n\nimport { createMetaQueue } from \"./createMetaQueue\";\n\n// TODO: don't use polyfill\nimport { posix } from \"path-browserify\";\nimport { cleanPath } from \"../../../../utils/cleanPath\";\n\nconst createFolderFn = async (masterHandle: MasterHandle, dir: string, name: string) => {\n\tconst fullDir = posix.join(dir, name)\n\n\tif (name.indexOf(\"/\") > 0 || name.length > 2 ** 8)\n\t\tthrow new Error(\"Invalid folder name\")\n\n\t// recurively create containing folders first\n\tif (!await masterHandle.getFolderMeta(dir).catch(console.warn))\n\t\tawait createFolder(masterHandle, posix.dirname(dir), posix.basename(dir))\n\n\tif (await masterHandle.getFolderMeta(fullDir).catch(console.warn))\n\t\tthrow new Error(\"Folder already exists\")\n\n\t// initialize as empty folder\n\tawait masterHandle.createFolderMeta(fullDir).catch(console.warn)\n\tawait masterHandle.setFolderMeta(fullDir, new FolderMeta({ name }))\n\n\tcreateMetaQueue(masterHandle, dir)\n\tmasterHandle.metaQueue[dir].push({\n\t\ttype: \"add-folder\",\n\t\tpayload: new FolderEntryMeta({\n\t\t\tname,\n\t\t\tlocation: masterHandle.getFolderLocation(fullDir)\n\t\t})\n\t})\n}\n\nconst createFolder = async (masterHandle: MasterHandle, dir: string, name: string) => {\n\tdir = cleanPath(dir)\n\tconst fullDir = posix.join(dir, name)\n\n\tif (masterHandle.metaFolderCreating[fullDir]) {\n\t\t// TODO: this is hacky\n\t\tawait new Promise(resolve => {\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tif (!masterHandle.metaFolderCreating[fullDir]) {\n\t\t\t\t\tresolve()\n\t\t\t\t\tclearInterval(interval)\n\t\t\t\t}\n\t\t\t}, 250)\n\t\t})\n\t\treturn\n\t}\n\n\tmasterHandle.metaFolderCreating[fullDir] = true\n\tawait createFolderFn(masterHandle, dir, name)\n\tmasterHandle.metaFolderCreating[fullDir] = false\n}\n\nexport { createFolder }\n","import { createMetadata } from \"../../../../core/requests/metadata\"\n\nimport { MasterHandle } from \"../../../../account\"\n\nimport { cleanPath } from \"../../../../utils/cleanPath\";\n\nconst createFolderMeta = async (masterHandle: MasterHandle, dir: string) => {\n\tdir = cleanPath(dir)\n\n\ttry {\n\t\t// TODO: verify folder can only be changed by the creating account\n\t\tawait createMetadata(\n\t\t\tmasterHandle.uploadOpts.endpoint,\n\t\t\tmasterHandle,\n\t\t\t// masterHandle.getFolderHDKey(dir),\n\t\t\tmasterHandle.getFolderLocation(dir)\n\t\t);\n\t} catch (err) {\n\t\tconsole.error(`Can't create folder metadata for folder ${ dir }`)\n\t\tthrow err\n\t}\n}\n\nexport { createFolderMeta }\n","import { NetQueue } from \"../../../../utils/netQueue\"\n\nimport { MasterHandle } from \"../../../../account\"\nimport { FolderMeta } from \"../../folder-meta\"\n\nimport { getFolderMeta } from \"./getFolderMeta\"\nimport { setFolderMeta } from \"./setFolderMeta\"\n\nimport { removeFile } from \"./meta/removeFile\"\nimport { removeVersion } from \"./meta/removeVersion\"\nimport { addFile } from \"./meta/addFile\"\nimport { addFolder } from \"./meta/addFolder\"\nimport { removeFolder } from \"./meta/removeFolder\"\n\nimport { cleanPath } from \"../../../../utils/cleanPath\"\n\nconst createMetaQueue = (masterHandle: MasterHandle, dir: string) => {\n\tdir = cleanPath(dir)\n\n\tif (masterHandle.metaQueue[dir])\n\t\treturn\n\n\tconst metaQueue = new NetQueue({\n\t\tfetch: async () => {\n\t\t\treturn getFolderMeta(masterHandle, dir)\n\t\t},\n\t\tupdate: async (meta: FolderMeta) => {\n\t\t\tawait setFolderMeta(masterHandle, dir, meta)\n\t\t}\n\t})\n\n\tconst types = [\n\t\t{ type: \"add-folder\", action: addFolder },\n\t\t{ type: \"add-file\", action: addFile },\n\t\t{ type: \"remove-folder\", action: removeFolder },\n\t\t{ type: \"remove-file\", action: removeFile },\n\t\t{ type: \"remove-version\", action: removeVersion }\n\t]\n\n\tfor (let type of types) {\n\t\tmetaQueue.addType({\n\t\t\ttype: type.type,\n\t\t\thandler: async (meta: FolderMeta, payload) => {\n\t\t\t\treturn await type.action(metaQueue, meta, payload)\n\t\t\t}\n\t\t})\n\t}\n\n\tmasterHandle.metaQueue[dir] = metaQueue\n}\n\nexport { createMetaQueue }\n","import { getFolderMeta } from \"./getFolderMeta\"\nimport { deleteVersion } from \"./deleteVersion\"\n\nimport { MasterHandle } from \"../../../../account\"\nimport { FileEntryMeta } from \"../../file-entry\"\n\nimport { createMetaQueue } from \"./createMetaQueue\"\n\nimport { cleanPath } from \"../../../../utils/cleanPath\"\n\nconst deleteFile = async (masterHandle: MasterHandle, dir: string, file: FileEntryMeta) => {\n\tdir = cleanPath(dir)\n\n\tconst meta = await getFolderMeta(masterHandle, dir)\n\n\tconst existingFile = meta.files.find(f => file === f || file.name === f.name)\n\n\t// precondition for if file is no longer in the metadata\n\tif (!existingFile)\n\t\treturn\n\n\tfor (let version of existingFile.versions) {\n\t\tawait deleteVersion(masterHandle, dir, version)\n\t}\n\n\tcreateMetaQueue(masterHandle, dir)\n\tmasterHandle.metaQueue[dir].push({\n\t\ttype: \"remove-file\",\n\t\tpayload: existingFile\n\t})\n}\n\nexport { deleteFile }\n","import { MasterHandle } from \"../../../../account\"\nimport { FolderEntryMeta } from \"../../folder-entry\"\nimport { createMetaQueue } from \"./createMetaQueue\";\n\nimport { posix } from \"path-browserify\";\nimport { cleanPath } from \"../../../../utils/cleanPath\";\n\nconst deleteFolder = async (masterHandle: MasterHandle, dir: string, folder: FolderEntryMeta) => {\n\tdir = cleanPath(dir)\n\tconst fullDir = posix.join(dir, folder.name)\n\n\tif (folder.name.indexOf(\"/\") > 0 || folder.name.length > 2 ** 8)\n\t\tthrow new Error(\"Invalid folder name\")\n\n\tconst meta = await masterHandle.getFolderMeta(fullDir).catch(console.warn)\n\n\tif (meta) {\n\t\tawait Promise.all([\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tfor (let folder of meta.folders) {\n\t\t\t\t\t\tawait masterHandle.deleteFolder(fullDir, folder)\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tconsole.error(\"Failed to delete sub folders\")\n\t\t\t\t\tthrow err\n\t\t\t\t}\n\t\t\t})(),\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tfor (let file of meta.files) {\n\t\t\t\t\t\tawait masterHandle.deleteFile(fullDir, file)\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tconsole.error(\"Failed to delete file\")\n\t\t\t\t\tthrow err\n\t\t\t\t}\n\t\t\t})()\n\t\t])\n\t}\n\n\ttry {\n\t\tawait masterHandle.deleteFolderMeta(fullDir)\n\t} catch (err) {\n\t\tconsole.error(\"Failed to delete meta entry\")\n\t\tthrow err\n\t}\n\n\tcreateMetaQueue(masterHandle, dir)\n\tmasterHandle.metaQueue[dir].push({\n\t\ttype: \"remove-folder\",\n\t\tpayload: folder\n\t})\n}\n\nexport { deleteFolder }\n","import { deleteMetadata } from \"../../../../core/requests/metadata\"\n\nimport { MasterHandle } from \"../../../../account\"\n\nimport { cleanPath } from \"../../../../utils/cleanPath\";\n\nconst deleteFolderMeta = async (masterHandle: MasterHandle, dir: string) => {\n\tdir = cleanPath(dir)\n\n\t// TODO: verify folder can only be changed by the creating account\n\tawait deleteMetadata(\n\t\tmasterHandle.uploadOpts.endpoint,\n\t\tmasterHandle,\n\t\t// masterHandle.getFolderHDKey(dir),\n\t\tmasterHandle.getFolderLocation(dir)\n\t);\n}\n\nexport { deleteFolderMeta }\n","import { deleteFile as requestDeleteFile } from \"../../../../core/requests/deleteFile\"\n\nimport { MasterHandle } from \"../../../../account\"\nimport { FolderMeta } from \"../../metadata\"\nimport { FileVersion } from \"../../file-version\"\nimport { createMetaQueue } from \"./createMetaQueue\";\n\nimport { cleanPath } from \"../../../../utils/cleanPath\";\n\nconst deleteVersion = async (masterHandle: MasterHandle, dir: string, version: FileVersion) => {\n\tdir = cleanPath(dir)\n\n\tawait requestDeleteFile(\n\t\tmasterHandle.uploadOpts.endpoint,\n\t\tmasterHandle,\n\t\t// only send the location, not the private key\n\t\tversion.handle.slice(0, 64)\n\t).catch(err => {\n\t\tconsole.warn(\"version does not exist\")\n\t\tconsole.warn(err)\n\t})\n\n\tcreateMetaQueue(masterHandle, dir)\n\tmasterHandle.metaQueue[dir].push({\n\t\ttype: \"remove-version\",\n\t\tpayload: version\n\t})\n}\n\nexport { deleteVersion }\n","import { util as ForgeUtil } from \"node-forge\";\n\nimport { hash } from \"../../../../core/hashing\";\nimport { getMetadata } from \"../../../../core/requests/metadata\";\nimport { decrypt } from \"../../../../core/encryption\";\n\nimport { MasterHandle } from \"../../../../account\";\nimport {\n\tFolderMeta,\n\tMinifiedFolderMeta\n} from \"../../../../core/account/folder-meta\";\n\nimport { createMetaQueue } from \"./createMetaQueue\"\n\nimport { cleanPath } from \"../../../../utils/cleanPath\";\n\nconst getFolderMeta = async (masterHandle: MasterHandle, dir: string): Promise<FolderMeta> => {\n\tdir = cleanPath(dir)\n\n\tcreateMetaQueue(masterHandle, dir)\n\n\tconst\n\t\tfolderKey = masterHandle.getFolderHDKey(dir),\n\t\tlocation = masterHandle.getFolderLocation(dir),\n\t\tkey = hash(folderKey.privateKey.toString(\"hex\")),\n\t\t// TODO: verify folder can only be read by the creating account\n\t\tresponse = await getMetadata(\n\t\t\tmasterHandle.uploadOpts.endpoint,\n\t\t\tmasterHandle,\n\t\t\t// folderKey,\n\t\t\tlocation\n\t\t)\n\n\ttry {\n\t\tconst metaString = (\n\t\t\tdecrypt(\n\t\t\t\tkey,\n\t\t\t\tnew ForgeUtil.ByteBuffer(Buffer.from(response.data.metadata, \"base64\"))\n\t\t\t) as ForgeUtil.ByteBuffer\n\t\t).toString();\n\n\t\ttry {\n\t\t\tconst meta = JSON.parse(metaString)\n\n\t\t\treturn new MinifiedFolderMeta(meta).unminify()\n\t\t} catch (err) {\n\t\t\tconsole.error(err)\n\t\t\tconsole.info(\"META STRING:\", metaString)\n\n\t\t\tthrow new Error(\"metadata corrupted\")\n\t\t}\n\t} catch (err) {\n\t\tconsole.error(err)\n\n\t\tthrow new Error(\"error decrypting meta\")\n\t}\n}\n\nexport { getFolderMeta }\n","import { checkPaymentStatus } from \"../../../../core/requests/checkPaymentStatus\";\nimport { MasterHandle } from \"../../../../account\";\n\nconst isExpired = async (masterHandle: MasterHandle) => {\n\ttry {\n\t\tconst accountInfoResponse = await checkPaymentStatus(masterHandle.uploadOpts.endpoint, masterHandle)\n\n\t\treturn accountInfoResponse.data.paymentStatus == \"expired\"\n\t} catch {\n\t\treturn false\n\t}\n}\n\nexport { isExpired }\n","import { FolderMeta } from \"../../../../core/account/folder-meta\";\nimport { MasterHandle } from \"../../../../account\";\n\nimport { getFolderMeta, isPaid } from \"../v0/index\";\nimport { isExpired } from \"./isExpired\";\n\nconst login = async (masterHandle: MasterHandle) => {\n\t// only attempt changes if account is paid\n\tif (!await isPaid(masterHandle)) {\n\t\treturn\n\t}\n\n\t// try newer meta\n\ttry {\n\t\tawait masterHandle.getFolderMeta(\"/\")\n\t} catch (err) {\n\t\t// try older meta\n\t\ttry {\n\t\t\tconst meta = await getFolderMeta(masterHandle, \"/\")\n\n\t\t\tawait masterHandle.deleteFolderMeta(\"/\").catch(console.warn)\n\t\t\tawait masterHandle.createFolderMeta(\"/\").catch(console.warn)\n\n\t\t\tconsole.info(\"--- META ---\", meta)\n\t\t\tawait masterHandle.setFolderMeta(\"/\", new FolderMeta(meta))\n\t\t} catch (err) {\n\t\t\t// no meta exists\n\t\t\t// set meta to an empty meta\n\t\t\tconsole.warn(err)\n\t\t\tawait masterHandle.createFolderMeta(\"/\").catch(console.warn)\n\t\t\tawait masterHandle.setFolderMeta(\"/\", new FolderMeta())\n\t\t}\n\t}\n}\n\nexport { login }\n","import { getFolderMeta } from \"./getFolderMeta\"\n\nimport { MasterHandle } from \"../../../../account\"\nimport { FileEntryMeta } from \"../../file-entry\"\n\nimport { createMetaQueue } from \"./createMetaQueue\"\n\nimport { cleanPath } from \"../../../../utils/cleanPath\"\n\ntype MoveFileArgs = {\n\tfile: FileEntryMeta,\n\tto: string\n}\n\nconst moveFile = async (masterHandle: MasterHandle, dir: string, { file, to }: MoveFileArgs) => {\n\tdir = cleanPath(dir)\n\n\tconst\n\t\tmeta = await getFolderMeta(masterHandle, dir).catch(console.warn),\n\t\ttoMeta = await getFolderMeta(masterHandle, to).catch(console.warn)\n\n\tif (!meta)\n\t\tthrow new Error(\"Folder does not exist\")\n\n\tif (!toMeta)\n\t\tthrow new Error(\"Can't move to folder that doesn't exist\")\n\n\tconst existingFile = meta.files.find(f => file === f || file.name === f.name)\n\n\t// file is no longer in the metadata\n\tif (!existingFile)\n\t\tthrow new Error(\"File no longer exists\")\n\n\tcreateMetaQueue(masterHandle, dir)\n\tcreateMetaQueue(masterHandle, to)\n\n\tmasterHandle.metaQueue[dir].push({\n\t\ttype: \"remove-file\",\n\t\tpayload: existingFile\n\t})\n\n\tmasterHandle.metaQueue[to].push({\n\t\ttype: \"add-file\",\n\t\tpayload: existingFile\n\t})\n}\n\nexport { moveFile, MoveFileArgs }\n","import { getFolderMeta } from \"./getFolderMeta\"\nimport { setFolderMeta } from \"./setFolderMeta\"\nimport { deleteFolderMeta } from \"./deleteFolderMeta\"\nimport { createFolder } from \"./createFolder\"\n\nimport { MasterHandle } from \"../../../../account\"\nimport { FolderEntryMeta } from \"../../folder-entry\"\n\nimport { createMetaQueue } from \"./createMetaQueue\"\nimport { createFolderMeta } from \"./createFolderMeta\";\n\nimport { posix } from \"path-browserify\"\nimport { cleanPath } from \"../../../../utils/cleanPath\"\n\ntype MoveFolderArgs = {\n\tfolder: FolderEntryMeta,\n\tto: string\n}\n\nconst moveFolder = async (masterHandle: MasterHandle, dir: string, { folder, to }: MoveFolderArgs) => {\n\tdir = cleanPath(dir)\n\n\tconst\n\t\toldDir = posix.join(dir, folder.name),\n\t\tnewDir = posix.join(to, folder.name)\n\n\tconst\n\t\tfolderMeta = await getFolderMeta(masterHandle, oldDir).catch(console.warn),\n\t\touterMeta = await getFolderMeta(masterHandle, dir).catch(console.warn),\n\t\ttoMeta = await getFolderMeta(masterHandle, to).catch(console.warn)\n\n\tif (!folderMeta)\n\t\tthrow new Error(\"Folder does not exist\")\n\n\tif (!outerMeta)\n\t\tthrow new Error(\"Outer folder does not exist\")\n\n\tif (!toMeta)\n\t\tthrow new Error(\"Can't move to folder that doesn't exist\")\n\n\tif (await getFolderMeta(masterHandle, newDir).catch(console.warn))\n\t\tthrow new Error(\"Folder already exists\")\n\n\tconst existingFolder = outerMeta.folders.find(f => folder === f || folder.name === f.name)\n\n\t// folder is no longer in the metadata\n\tif (!existingFolder)\n\t\tthrow new Error(\"File no longer exists\")\n\n\tawait createFolderMeta(masterHandle, newDir).catch(console.warn)\n\tawait setFolderMeta(masterHandle, newDir, await getFolderMeta(masterHandle, oldDir))\n\tawait deleteFolderMeta(masterHandle, oldDir)\n\n\tcreateMetaQueue(masterHandle, dir)\n\tcreateMetaQueue(masterHandle, to)\n\n\tmasterHandle.metaQueue[dir].push({\n\t\ttype: \"remove-folder\",\n\t\tpayload: existingFolder\n\t})\n\n\tmasterHandle.metaQueue[to].push({\n\t\ttype: \"add-folder\",\n\t\tpayload: existingFolder\n\t})\n}\n\nexport { moveFolder, MoveFolderArgs }\n","import { getFolderMeta } from \"./getFolderMeta\"\n\nimport { MasterHandle } from \"../../../../account\"\nimport { FileEntryMeta } from \"../../file-entry\"\n\nimport { createMetaQueue } from \"./createMetaQueue\"\n\nimport { cleanPath } from \"../../../../utils/cleanPath\"\n\ntype RenameFileArgs = {\n\tfile: FileEntryMeta,\n\tname: string\n}\n\nconst renameFile = async (masterHandle: MasterHandle, dir: string, { file, name }: RenameFileArgs) => {\n\tdir = cleanPath(dir)\n\n\tconst meta = await getFolderMeta(masterHandle, dir).catch(console.warn)\n\n\tif (!meta)\n\t\tthrow new Error(\"Folder does not exist\")\n\n\tconst existingFile = meta.files.find(f => file === f || file.name === f.name)\n\n\t// file is no longer in the metadata\n\tif (!existingFile)\n\t\tthrow new Error(\"File no longer exists\")\n\n\tcreateMetaQueue(masterHandle, dir)\n\n\tmasterHandle.metaQueue[dir].push({\n\t\ttype: \"remove-file\",\n\t\tpayload: existingFile\n\t})\n\n\tmasterHandle.metaQueue[dir].push({\n\t\ttype: \"add-file\",\n\t\tpayload: new FileEntryMeta({\n\t\t\t...existingFile,\n\t\t\tname\n\t\t})\n\t})\n}\n\nexport { renameFile, RenameFileArgs }\n","import { getFolderMeta } from \"./getFolderMeta\"\nimport { setFolderMeta } from \"./setFolderMeta\"\nimport { deleteFolderMeta } from \"./deleteFolderMeta\"\nimport { getFolderLocation } from \"./index\"\n\nimport { MasterHandle } from \"../../../../account\"\nimport { FolderEntryMeta } from \"../../folder-entry\"\n\nimport { createMetaQueue } from \"./createMetaQueue\"\nimport { createFolder } from \"./createFolder\";\n\nimport { posix } from \"path-browserify\"\nimport { cleanPath } from \"../../../../utils/cleanPath\"\n\ntype RenameFolderArgs = {\n\tfolder: FolderEntryMeta,\n\tname: string\n}\n\nconst renameFolder = async (masterHandle: MasterHandle, dir: string, { folder, name }: RenameFolderArgs) => {\n\tdir = cleanPath(dir)\n\n\tif (name.indexOf(\"/\") > 0 || name.length > 2 ** 8)\n\t\tthrow new Error(\"Invalid folder name\")\n\n\tconst\n\t\toldDir = posix.join(dir, folder.name),\n\t\tnewDir = posix.join(dir, name)\n\n\tconst\n\t\tfolderMeta = await getFolderMeta(masterHandle, dir).catch(console.warn),\n\t\tmeta = await getFolderMeta(masterHandle, dir).catch(console.warn)\n\n\tif (!folderMeta)\n\t\tthrow new Error(\"Folder does not exist\")\n\n\tif (!meta)\n\t\tthrow new Error(\"Outer folder does not exist\")\n\n\tif (await getFolderMeta(masterHandle, newDir).catch(console.warn))\n\t\tthrow new Error(\"Folder already exists\")\n\n\tconst existingFolder = meta.folders.find(f => folder === f || folder.name === f.name)\n\n\t// folder is no longer in the metadata\n\tif (!existingFolder)\n\t\tthrow new Error(\"Folder no longer exists\")\n\n\tawait createFolder(masterHandle, dir, name)\n\tawait setFolderMeta(masterHandle, newDir, await getFolderMeta(masterHandle, oldDir))\n\tawait deleteFolderMeta(masterHandle, oldDir)\n\n\tcreateMetaQueue(masterHandle, dir)\n\n\tmasterHandle.metaQueue[dir].push({\n\t\ttype: \"remove-folder\",\n\t\tpayload: existingFolder\n\t})\n\n\tmasterHandle.metaQueue[dir].push({\n\t\ttype: \"add-folder\",\n\t\tpayload: new FolderEntryMeta({\n\t\t\tname,\n\t\t\tlocation: getFolderLocation(masterHandle, newDir)\n\t\t})\n\t})\n}\n\nexport { renameFolder, RenameFolderArgs }\n","import { renewAccountStatus, renewAccountInvoice } from \"../../../requests/renewAccount\";\nimport { buildFullTree } from \"./buildFullTree\";\n\nimport { MasterHandle } from \"../../../../account\";\nimport { getFolderLocation } from \"../v0/getFolderLocation\";\n\nconst renewAccount = async (masterHandle: MasterHandle, duration?: number) => {\n\tconst tree = await buildFullTree(masterHandle, \"/\")\n\n\tconst metadataKeys = Object.keys(tree).map(dir => getFolderLocation(masterHandle, dir))\n\tconst fileHandles = Object.values(tree).map(folder => folder.files.map(file => file.versions.map(version => version.handle.slice(0, 64)))).flat(2)\n\n\tconsole.log(metadataKeys, fileHandles)\n\n\tconst renewAccountInvoiceResponse = await renewAccountInvoice(masterHandle.uploadOpts.endpoint, masterHandle, duration)\n\n\tconsole.log(renewAccountInvoiceResponse)\n\n\tconst renewAccountStatusOpts: [\n\t\tstring,\n\t\tMasterHandle,\n\t\tstring[],\n\t\tstring[],\n\t\tnumber\n\t] = [\n\t\tmasterHandle.uploadOpts.endpoint,\n\t\tmasterHandle,\n\t\tmetadataKeys,\n\t\tfileHandles,\n\t\tduration\n\t]\n\n\treturn {\n\t\tdata: renewAccountInvoiceResponse.data,\n\t\twaitForPayment: () => new Promise(resolve => {\n\t\t\tconst interval = setInterval(async () => {\n\t\t\t\t// don't perform run if it takes more than 5 seconds for response\n\t\t\t\tconst time = Date.now()\n\n\t\t\t\tconst renewAccountStatusResponse = await renewAccountStatus(...renewAccountStatusOpts)\n\n\t\t\t\tconsole.log(renewAccountStatusResponse)\n\n\t\t\t\tif (\n\t\t\t\t\trenewAccountStatusResponse.data.status\n\t\t\t\t\t&& renewAccountStatusResponse.data.status !== \"Incomplete\"\n\t\t\t\t\t&& time + 5 * 1000 > Date.now()\n\t\t\t\t) {\n\t\t\t\t\tclearInterval(interval)\n\n\t\t\t\t\tawait masterHandle.login()\n\n\t\t\t\t\tresolve({ data: renewAccountStatusResponse.data })\n\t\t\t\t}\n\t\t\t}, 10 * 1000)\n\t\t})\n\t}\n}\n\nexport { renewAccount }\n","import { hash } from \"../../../hashing\";\nimport { encryptString } from \"../../../encryption\";\nimport { setMetadata } from \"../../../requests/metadata\";\n\nimport { MasterHandle } from \"../../../../account\";\nimport { FolderMeta } from \"../../folder-meta\";\n\nimport { cleanPath } from \"../../../../utils/cleanPath\";\n\nconst setFolderMeta = async (masterHandle: MasterHandle, dir: string, folderMeta: FolderMeta) => {\n\tdir = cleanPath(dir)\n\n\tconst\n\t\tfolderKey = masterHandle.getFolderHDKey(dir),\n\t\tkey = hash(folderKey.privateKey.toString(\"hex\")),\n\t\tmetaString = JSON.stringify(folderMeta.minify()),\n\t\tencryptedMeta = Buffer.from(encryptString(key, metaString, \"utf8\").toHex(), \"hex\").toString(\"base64\")\n\n\t// TODO: verify folder can only be changed by the creating account\n\tawait setMetadata(\n\t\tmasterHandle.uploadOpts.endpoint,\n\t\tmasterHandle,\n\t\t// masterHandle.getFolderHDKey(dir),\n\t\tmasterHandle.getFolderLocation(dir),\n\t\tencryptedMeta\n\t);\n}\n\nexport { setFolderMeta }\n","import { upgradeAccountStatus, upgradeAccountInvoice } from \"../../../requests/upgradeAccount\";\nimport { buildFullTree } from \"./buildFullTree\";\n\nimport { MasterHandle } from \"../../../../account\";\nimport { getFolderLocation } from \"../v0/getFolderLocation\";\n\nconst upgradeAccount = async (masterHandle: MasterHandle, duration?: number, limit?: number) => {\n\tconst tree = await buildFullTree(masterHandle, \"/\")\n\n\tconst metadataKeys = Object.keys(tree).map(dir => getFolderLocation(masterHandle, dir))\n\tconst fileHandles = Object.values(tree).map(folder => folder.files.map(file => file.versions.map(version => version.handle.slice(0, 64)))).flat(2)\n\n\tconsole.log(metadataKeys, fileHandles)\n\n\tconst upgradeAccountInvoiceResponse = await upgradeAccountInvoice(masterHandle.uploadOpts.endpoint, masterHandle, duration, limit)\n\n\tconsole.log(upgradeAccountInvoiceResponse)\n\n\tconst upgradeAccountStatusOpts: [\n\t\tstring,\n\t\tMasterHandle,\n\t\tstring[],\n\t\tstring[],\n\t\tnumber,\n\t\tnumber\n\t] = [\n\t\tmasterHandle.uploadOpts.endpoint,\n\t\tmasterHandle,\n\t\tmetadataKeys,\n\t\tfileHandles,\n\t\tduration,\n\t\tlimit\n\t]\n\n\treturn {\n\t\tdata: upgradeAccountInvoiceResponse.data,\n\t\twaitForPayment: () => new Promise(resolve => {\n\t\t\tconst interval = setInterval(async () => {\n\t\t\t\t// don't perform run if it takes more than 5 seconds for response\n\t\t\t\tconst time = Date.now()\n\n\t\t\t\tconst upgradeAccountStatusResponse = await upgradeAccountStatus(...upgradeAccountStatusOpts)\n\n\t\t\t\tconsole.log(upgradeAccountStatusResponse)\n\n\t\t\t\tif (\n\t\t\t\t\tupgradeAccountStatusResponse.data.status\n\t\t\t\t\t&& upgradeAccountStatusResponse.data.status !== \"Incomplete\"\n\t\t\t\t\t&& time + 5 * 1000 > Date.now()\n\t\t\t\t) {\n\t\t\t\t\tclearInterval(interval)\n\n\t\t\t\t\tawait masterHandle.login()\n\n\t\t\t\t\tresolve({ data: upgradeAccountStatusResponse.data })\n\t\t\t\t}\n\t\t\t}, 10 * 1000)\n\t\t})\n\t}\n}\n\nexport { upgradeAccount }\n","import { EventEmitter } from \"events\";\nimport Upload from \"../../../../upload\";\n\nimport { MasterHandle } from \"../../../../account\";\nimport { FileEntryMeta } from \"../../file-entry\";\nimport { FileVersion } from \"../../file-version\";\nimport { createMetaQueue } from \"./createMetaQueue\";\nimport { getFolderMeta } from \"./getFolderMeta\";\nimport { createFolder } from \"./createFolder\";\n\nimport { posix } from \"path-browserify\";\nimport { cleanPath } from \"../../../../utils/cleanPath\";\n\nconst uploadFile = (masterHandle: MasterHandle, dir: string, file: File) => {\n\tdir = cleanPath(dir)\n\n\tconst\n\t\tupload = new Upload(file, masterHandle, masterHandle.uploadOpts),\n\t\tee = new EventEmitter();\n\n\tObject.assign(ee, { handle:  upload.handle });\n\n\tupload.on(\"upload-progress\", progress => {\n\t\tee.emit(\"upload-progress\", progress);\n\t});\n\n\tupload.on(\"error\", err => {\n\t\tee.emit(\"error\", err);\n\t});\n\n\tupload.on(\"finish\", async (finishedUpload: { handle: string, [key: string]: any }) => {\n\t\tif (!await getFolderMeta(masterHandle, dir).catch(console.warn))\n\t\t\tawait createFolder(masterHandle, posix.dirname(dir), posix.basename(dir))\n\n\t\tcreateMetaQueue(masterHandle, dir)\n\t\tmasterHandle.metaQueue[dir].push({\n\t\t\ttype: \"add-file\",\n\t\t\tpayload: new FileEntryMeta({\n\t\t\t\tname: file.name,\n\t\t\t\tmodified: file.lastModified,\n\t\t\t\tversions: [\n\t\t\t\t\tnew FileVersion({\n\t\t\t\t\t\thandle: finishedUpload.handle,\n\t\t\t\t\t\tsize: file.size,\n\t\t\t\t\t\tmodified: file.lastModified\n\t\t\t\t\t})\n\t\t\t\t]\n\t\t\t})\n\t\t})\n\n\t\tmasterHandle.metaQueue[dir].once(\"update\", meta => {\n\t\t\tee.emit(\"finish\", finishedUpload)\n\t\t})\n\t})\n\n\treturn ee\n}\n\nexport { uploadFile }\n","import { posix } from \"path-browserify\"\nimport { keccak_256 } from \"js-sha3\"\n\nexport const pathHash = (path: string): Uint8Array => {\n\tpath = posix.normalize(path)\n\n\tlet node = new Uint8Array(32)\n\n\tif (path) {\n\t\tvar labels = path.split(\"/\")\n\n\t\tfor (var i = 0; i < labels.length; i++) {\n\t\t\tvar labelSha = new Uint8Array(keccak_256.arrayBuffer(labels[i]))\n\t\t\tnode = new Uint8Array(keccak_256.arrayBuffer(new Uint8Array(Array.from(node).concat(Array.from(labelSha)))))\n\t\t}\n\t}\n\n\treturn node\n}\n\nexport const hashToPath = (hash: Uint8Array): string => {\n\tif (hash.length % 2) {\n\t\tthrow new Error(\"hash length must be multiple of two bytes\")\n\t}\n\n\treturn (\n\t\t\"\" + new Uint16Array(hash.buffer, hash.byteOffset, hash.byteLength / Uint16Array.BYTES_PER_ELEMENT).join(\"'/\") + \"'\"\n\t)\n}\n\n/**\n * @internal\n * DO NOT USE. Incomplete implementation of namehash.\n * Missing IDNA-UTS #46 normalization\n */\nexport const nameHash = (name: string) => {\n\treturn pathHash(name.split(\".\").reverse().join(\"/\"))\n}\n","import Axios from \"axios\";\nimport { EventEmitter } from \"events\";\nimport { pipeline } from \"readable-stream\";\nimport { decryptMetadata } from \"./core/metadata\";\nimport { getPayload } from \"./core/request\";\nimport {\n  getMimeType,\n  getUploadSize,\n  keysFromHandle\n} from \"./core/helpers\";\n\nimport { FileMeta } from \"./core/metadata\"\n\nimport DecryptStream from \"./streams/decryptStream\";\nimport DownloadStream from \"./streams/downloadStream\";\n\nconst METADATA_PATH = \"/download/metadata/\";\n\ntype DownloadOptions = {\n  autoStart?: boolean\n  endpoint?: string\n}\n\nconst DEFAULT_OPTIONS: DownloadOptions = Object.freeze({\n  autoStart: true\n});\n\n/**\n * @internal\n */\nexport default class Download extends EventEmitter {\n  options: DownloadOptions\n  handle: string\n  hash: string\n  key: string\n  downloadURLRequest\n  metadataRequest\n  downloadURL: string\n  isDownloading: boolean\n  decryptStream: DecryptStream\n  downloadStream: DownloadStream\n  _metadata: FileMeta\n\n  private size\n\n  constructor(handle, opts: DownloadOptions = {}) {\n    super();\n\n    const options = Object.assign({}, DEFAULT_OPTIONS, opts);\n    const { hash, key } = keysFromHandle(handle);\n\n    this.options = options;\n    this.handle = handle;\n    this.hash = hash;\n    this.key = key;\n    this.downloadURLRequest = null;\n    this.metadataRequest = null;\n    this.isDownloading = false;\n\n    if(options.autoStart) {\n      this.startDownload();\n    }\n  }\n\n  metadata = async () => {\n    if(this._metadata) {\n      return this._metadata;\n    } else {\n      return await this.downloadMetadata();\n    }\n  }\n\n  toBuffer = async () => {\n    const chunks = [];\n    let totalLength = 0;\n\n    if(typeof Buffer === \"undefined\") {\n      return false;\n    }\n\n    await this.startDownload();\n\n    return new Promise(resolve => {\n      this.decryptStream.on(\"data\", (data) => {\n        chunks.push(data);\n        totalLength += data.length;\n      });\n\n      this.decryptStream.once(\"finish\", () => {\n        resolve(Buffer.concat(chunks, totalLength));\n      });\n    }).catch(err => {\n      throw err;\n    });\n  }\n\n  toFile = async () => {\n    const chunks = [] as BlobPart[];\n    let totalLength = 0;\n\n    await this.startDownload();\n\n    return new Promise(resolve => {\n      this.decryptStream.on(\"data\", (data) => {\n        chunks.push(data);\n        totalLength += data.length;\n      })\n\n      this.decryptStream.once(\"finish\", async () => {\n        const meta = await this.metadata();\n        resolve(new File(chunks, meta.name, {\n          type: getMimeType(meta)\n        }));\n      })\n    }).catch(err => {\n      throw err;\n    })\n  }\n\n  startDownload = async () => {\n    try {\n      await this.getDownloadURL();\n      await this.downloadMetadata();\n      await this.downloadFile();\n    } catch(e) {\n      this.propagateError(e);\n    }\n  }\n\n  getDownloadURL = async (overwrite = false) => {\n    let req;\n\n    if(!overwrite && this.downloadURLRequest) {\n      req = this.downloadURLRequest;\n    } else {\n      req = Axios.post(this.options.endpoint + \"/api/v1/download\", {\n        fileID: this.hash\n      });\n      this.downloadURLRequest = req;\n    }\n\n    const res = await req;\n\n    if(res.status === 200) {\n      this.downloadURL = res.data.fileDownloadUrl;\n      return this.downloadURL;\n    }\n  }\n\n  downloadMetadata = async (overwrite = false) => {\n    let req;\n\n    if(!this.downloadURL) {\n      await this.getDownloadURL();\n    }\n\n    if(!overwrite && this.metadataRequest) {\n      req = this.metadataRequest;\n    } else {\n      const endpoint = this.options.endpoint;\n      const path = METADATA_PATH + this.hash;\n      req = Axios.get(this.downloadURL + \"/metadata\", {\n        responseType: \"arraybuffer\"\n      });\n      this.metadataRequest = req;\n    }\n\n    const res = await req;\n    const metadata = decryptMetadata(new Uint8Array(res.data), this.key);\n\n    this._metadata = metadata;\n    this.size = getUploadSize(metadata.size, metadata.p || {});\n    return metadata;\n  }\n\n  downloadFile = async () => {\n    if(this.isDownloading) {\n      return true;\n    }\n\n    this.isDownloading = true;\n    this.downloadStream = new DownloadStream(this.downloadURL, await this.metadata, this.size, this.options);\n    this.decryptStream = new DecryptStream(this.key);\n\n    this.downloadStream.on(\"progress\", progress => {\n      this.emit(\"download-progress\", {\n        target: this,\n        handle: this.handle,\n        progress: progress\n      })\n    });\n\n    this.downloadStream\n      .pipe(this.decryptStream)\n\n    this.downloadStream.on(\"error\", this.propagateError);\n    this.decryptStream.on(\"error\", this.propagateError);\n  }\n\n  finishDownload = (error) => {\n    if(error) {\n      this.propagateError(error);\n    } else {\n      this.emit(\"finish\");\n    }\n  }\n\n  propagateError = (error) => {\n    console.warn(\"Download error: \", error.message || error);\n    process.nextTick(() => this.emit(\"error\", error.message || error));\n  }\n}\n","import { soliditySha3, Mixed } from \"web3-utils\"\n\nexport const hash = <T extends Mixed>(...val: T[]) => {\n\treturn soliditySha3(...val).replace(/^0x/, \"\")\n}\n","import Axios from \"axios\";\nimport HDKey from \"hdkey\";\n\nimport { getPayload } from \"../request\";\n\n/**\n * check whether a payment has gone through for an account\n *\n * @param endpoint - the base url to send the request to\n * @param hdNode - the account to check\n *\n * @internal\n */\nexport async function checkPaymentStatus(endpoint: string, hdNode: HDKey) {\n  const payload = {\n    timestamp: Math.floor(Date.now() / 1000)\n  }\n\n  const signedPayload = getPayload(payload, hdNode);\n\n  return Axios.post(endpoint + \"/api/v1/account-data\", signedPayload);\n}\n","// TODO: don't use polyfill\nimport { posix } from \"path-browserify\"\n\nconst posixSep = new RegExp(posix.sep + \"+\", \"g\")\nconst posixSepEnd = new RegExp(\"(.)\" + posix.sep + \"+$\")\n// NOTE: win32 isn't included in the polyfill\nconst win32Sep = new RegExp(\"\\\\+\", \"g\")\n\nconst trimTrailingSep = (path: string) => {\n\treturn path.replace(posixSepEnd, \"$1\")\n}\n\nconst cleanPath = (path: string) => {\n\treturn trimTrailingSep(path.replace(win32Sep, posix.sep).replace(posixSep, posix.sep))\n}\n\nexport { cleanPath }\n","import Axios from \"axios\";\nimport HDKey from \"hdkey\";\n\nimport { getPayload } from \"../request\";\n\n/**\n * request the creation of an account\n *\n * @param endpoint - the base url to send the request to\n * @param hdNode - the account to create\n * @param metadataKey\n * @param duration - account duration in months\n * @param limit - storage limit in GB\n *\n * @internal\n */\nexport async function createAccount(endpoint: string, hdNode: HDKey, metadataKey: string, duration = 12, limit = 128) {\n  const payload = {\n    metadataKey: metadataKey,\n    durationInMonths: duration,\n    storageLimit: limit\n  }\n\n  const signedPayload = getPayload(payload, hdNode);\n\n  return Axios.post(endpoint + \"/api/v1/accounts\", signedPayload);\n}\n","import { EventEmitter } from \"events\"\nimport debounce from \"debounce\"\n\ntype NetQueueProps<T> = {\n\tfetch: () => T | Promise<T>\n\tupdate: (obj: T) => void\n\tdata?: { [key: string]: any }\n\ttimeout?: number\n}\n\ntype NetQueueEntry = {\n\ttype: string\n\tpayload: any\n}\n\ntype NetQueueType<T> = {\n\ttype: string\n\thandler: (obj: T, payload: any) => T | Promise<T>\n}\n\nclass NetQueue<T> extends EventEmitter {\n\tupdating = false\n\tqueue: NetQueueEntry[] = []\n\ttypes: { [type: string]: (obj: T, payload: any) => T | Promise<T> } = {}\n\n\tresult: T\n\n\tdata: { [key: string]: any } = {}\n\n\tprivate _fetch: () => T | Promise<T>\n\tprivate _update: (obj: T) => void\n\tprivate _timeout: number\n\n\tconstructor ({ fetch, update, data = {}, timeout = 1000 }: NetQueueProps<T>) {\n\t\tsuper()\n\n\t\tthis._fetch = fetch\n\t\tthis._update = update\n\n\t\tthis.data = data\n\n\t\tthis._timeout = timeout\n\t}\n\n\tpush = ({ type, payload }: NetQueueEntry) => {\n\t\tthis.queue.push({ type, payload })\n\n\t\tthis._process()\n\t}\n\n\taddType = ({ type, handler }: NetQueueType<T>) => {\n\t\tthis.types[type] = handler\n\t}\n\n\tprivate _process = debounce(async () => {\n\t\tif (this.updating)\n\t\t\treturn\n\n\t\tthis.updating = true\n\n\t\tconst queueCopy = Object.assign([] as NetQueueEntry[], this.queue)\n\n\t\tthis.result = await Promise.resolve(this._fetch())\n\n\t\tfor (let { type, payload } of queueCopy) {\n\t\t\tif (this.types[type])\n\t\t\t\tthis.result = await Promise.resolve(this.types[type](this.result, payload))\n\t\t\telse\n\t\t\t\tthrow new Error(\"unknown type: \" + type)\n\n\t\t\tthis.queue.shift()\n\t\t}\n\n\t\tawait Promise.resolve(this._update(this.result))\n\n\t\tthis.updating = false\n\n\t\tthis.emit(\"update\", this.result)\n\n\t\tif (this.queue.length)\n\t\t\tthis._process()\n\t}, this._timeout)\n}\n\nexport { NetQueue, NetQueueProps, NetQueueEntry, NetQueueType }\n","import { NetQueue } from \"../../../../../utils/netQueue\"\n\nimport { FileEntryMeta } from \"../../../file-entry\"\nimport { FolderMeta } from \"../../../folder-meta\"\n\nconst removeFile = async (metaQueue: NetQueue<FolderMeta>, meta: FolderMeta, file: FileEntryMeta) => {\n\t// precondition for if file is no longer in the metadata\n\tif (!meta.files.find(f => file === f || file.name === f.name))\n\t\treturn meta\n\n\tmeta.files = meta.files.filter(f => file !== f && file.name !== f.name)\n\n\treturn meta\n}\n\nexport { removeFile }\n","import { NetQueue } from \"../../../../../utils/netQueue\"\n\nimport { FolderMeta } from \"../../../metadata\"\nimport { FileVersion } from \"../../../file-version\"\n\nconst removeVersion = async (metaQueue: NetQueue<FolderMeta>, meta: FolderMeta, version: FileVersion) => {\n\tconst file = meta.files.find(f => f.versions.includes(version) || !!f.versions.find(v => version.handle === v.handle))\n\n\t// precondition for if version no longer exists in meta\n\tif (!file)\n\t\treturn meta\n\n\tfile.versions = file.versions.filter(v => version !== v && version.handle !== v.handle)\n\n\tif (file.versions.length === 0)\n\t\tmetaQueue.push({\n\t\t\ttype: \"remove-file\",\n\t\t\tpayload: file\n\t\t})\n\n\treturn meta\n}\n\nexport { removeVersion }\n","import { NetQueue } from \"../../../../../utils/netQueue\"\n\nimport { FolderMeta } from \"../../../folder-meta\"\nimport { FileEntryMeta } from \"../../../file-entry\"\n\nconst addFile = (metaQueue: NetQueue<FolderMeta>, meta: FolderMeta, file: FileEntryMeta) => {\n\tconst existingFile = meta.files.find(f => file === f || file.name === f.name)\n\n\tif (existingFile) {\n\t\texistingFile.modified = file.modified\n\t\texistingFile.versions = [...existingFile.versions, ...file.versions]\n\t} else {\n\t\tmeta.files.push(file)\n\t}\n\n\treturn meta\n}\n\nexport { addFile }\n","import { NetQueue } from \"../../../../../utils/netQueue\"\n\nimport { FolderMeta } from \"../../../folder-meta\"\nimport { FolderEntryMeta } from \"../../../folder-entry\"\n\nconst addFolder = (metaQueue: NetQueue<FolderMeta>, meta: FolderMeta, folder: FolderEntryMeta) => {\n\tconst existingFolder = meta.folders.find(f => folder === f || folder.name === f.name)\n\n\tif (!existingFolder)\n\t\tmeta.folders.push(folder)\n\n\treturn meta\n}\n\nexport { addFolder }\n","import { NetQueue } from \"../../../../../utils/netQueue\"\n\nimport { FolderEntryMeta } from \"../../../folder-entry\"\nimport { FolderMeta } from \"../../../folder-meta\"\n\nconst removeFolder = async (metaQueue: NetQueue<FolderMeta>, meta: FolderMeta, folder: FolderEntryMeta) => {\n\t// precondition for if folder is no longer in the metadata\n\tif (!meta.folders.find(f => folder === f || folder.name === f.name))\n\t\treturn meta\n\n\tmeta.folders = meta.folders.filter(f => folder !== f && folder.name !== f.name)\n\n\treturn meta\n}\n\nexport { removeFolder }\n","import Axios from \"axios\";\nimport HDKey from \"hdkey\";\n\nimport { getPayload } from \"../request\";\n\n/**\n * request creating a metadata entry\n *\n * @param endpoint - the base url to send the request to\n * @param hdNode - the account to access\n * @param metadataKey - the key associated with the metadata\n *\n * @internal\n */\nexport async function createMetadata(endpoint: string, hdNode: HDKey, metadataKey: string) {\n  const timestamp = Math.floor(Date.now() / 1000);\n  const payload = { timestamp, metadataKey };\n  const signedPayload = getPayload(payload, hdNode);\n\n  return Axios.post(endpoint + \"/api/v1/metadata/create\", signedPayload);\n}\n\n/**\n * request deleting a metadata entry\n *\n * @param endpoint - the base url to send the request to\n * @param hdNode - the account to access\n * @param metadataKey - the key associated with the metadata\n *\n * @internal\n */\nexport async function deleteMetadata(endpoint: string, hdNode: HDKey, metadataKey: string) {\n  const timestamp = Math.floor(Date.now() / 1000);\n  const payload = { timestamp, metadataKey };\n  const signedPayload = getPayload(payload, hdNode);\n\n  return Axios.post(endpoint + \"/api/v1/metadata/delete\", signedPayload);\n}\n\n/**\n * request changing a metadata entry\n *\n * @param endpoint - the base url to send the request to\n * @param hdNode - the account to access\n * @param metadataKey - the key associated with the metadata\n * @param metadata - the metadata to put\n *\n * @internal\n */\nexport async function setMetadata(endpoint: string, hdNode: HDKey, metadataKey: string, metadata: string) {\n  const timestamp = Math.floor(Date.now() / 1000);\n  const payload = { timestamp, metadata, metadataKey };\n  const signedPayload = getPayload(payload, hdNode);\n\n  return Axios.post(endpoint + \"/api/v1/metadata/set\", signedPayload);\n}\n\n/**\n * request get of a metadata entry\n *\n * @param endpoint - the base url to send the request to\n * @param hdNode - the account to access\n * @param metadataKey - the key associated with the metadata\n *\n * @internal\n */\nexport async function getMetadata(endpoint: string, hdNode: HDKey, metadataKey: string) {\n  const timestamp = Math.floor(Date.now() / 1000);\n  const payload = { timestamp, metadataKey };\n  const signedPayload = getPayload(payload, hdNode);\n\n  return Axios.post(endpoint + \"/api/v1/metadata/get\", signedPayload);\n}\n","import Axios from \"axios\";\nimport HDKey from \"hdkey\";\n\nimport { getPayload } from \"../request\";\n\n// Metadata as hexstring as of right now\nexport async function deleteFile(endpoint: string, hdNode: HDKey, fileID: string) {\n  const payload = { fileID };\n  const signedPayload = getPayload(payload, hdNode);\n\n  return Axios.post(endpoint + \"/api/v1/delete\", signedPayload);\n}\n","import { cipher as ForgeCipher, md as ForgeMd, util as ForgeUtil, random as ForgeRandom, Encoding } from \"node-forge\"\nimport { IV_BYTE_LENGTH, TAG_BYTE_LENGTH, TAG_BIT_LENGTH, BLOCK_OVERHEAD } from \"./constants\";\n\nconst Forge = { cipher: ForgeCipher, md: ForgeMd, util: ForgeUtil, random: ForgeRandom };\nconst ByteBuffer = Forge.util.ByteBuffer;\n\n// Encryption\nexport function encrypt(key, byteBuffer: ForgeUtil.ByteBuffer) {\n  const keyBuf = new ByteBuffer(Buffer.from(key, \"hex\"))\n  const iv = Forge.random.getBytesSync(IV_BYTE_LENGTH);\n  const cipher = Forge.cipher.createCipher(\"AES-GCM\", keyBuf);\n\n  cipher.start({\n    iv,\n    tagLength: TAG_BIT_LENGTH\n  });\n\n  cipher.update(byteBuffer);\n  cipher.finish();\n\n  byteBuffer.clear();\n  byteBuffer.putBuffer(cipher.output);\n  byteBuffer.putBuffer(cipher.mode.tag);\n  byteBuffer.putBytes(iv);\n\n  return byteBuffer;\n}\n\nexport function encryptString(key: string, string: string, encoding: Encoding = \"utf8\") {\n  const buf = Forge.util.createBuffer(string, encoding);\n  return encrypt(key, buf);\n}\n\nexport function encryptBytes(key, bytes) {\n  return encrypt(key, Forge.util.createBuffer(bytes));\n}\n\n// Decryption\nexport function decrypt(key: string, byteBuffer: ForgeUtil.ByteBuffer) {\n  const keyBuf = new ByteBuffer(Buffer.from(key, \"hex\"))\n\n  keyBuf.read = 0;\n  byteBuffer.read = byteBuffer.length() - BLOCK_OVERHEAD;\n\n  const tag = byteBuffer.getBytes(TAG_BYTE_LENGTH);\n  const iv = byteBuffer.getBytes(IV_BYTE_LENGTH);\n  const decipher = Forge.cipher.createDecipher(\"AES-GCM\", keyBuf);\n\n  byteBuffer.read = 0;\n  (byteBuffer.truncate as (count: number) => ForgeUtil.ByteBuffer)(BLOCK_OVERHEAD);\n  decipher.start({\n    iv,\n    // the type definitions are wrong in @types/node-forge\n    tag: tag as unknown as ForgeUtil.ByteBuffer,\n    tagLength: TAG_BIT_LENGTH\n  });\n  decipher.update(byteBuffer);\n\n  if (decipher.finish()) {\n    return decipher.output;\n  } else {\n    return false;\n  }\n}\n\nexport function decryptBytes(key, bytes) {\n  const buf = new ByteBuffer(bytes);\n  const output = decrypt(key, buf);\n  if (output) {\n    return Forge.util.binary.raw.decode(output.getBytes());\n  } else {\n    return false;\n  }\n}\n\nexport function decryptString(key: string, byteBuffer: ForgeUtil.ByteBuffer, encoding = \"utf8\") {\n  const output = decrypt(key, byteBuffer);\n\n  if (output) {\n    return Buffer.from(output.toString()).toString(encoding);\n  } else {\n    throw new Error(\"unable to decrypt\");\n  }\n}\n","import { FileEntryMeta, MinifiedFileEntryMeta, MinifiedFileEntryMetaProps } from \"./file-entry\"\nimport { FolderEntryMeta, MinifiedFolderEntryMeta, MinifiedFolderEntryMetaProps } from \"./folder-entry\"\n\n/**\n * metadata to describe a folder for the UI\n *\n * @public\n */\nclass FolderMeta {\n\t/** a nickname shown on the folder when accessed without adding to account metadata */\n\tname: string\n\t/** the files included only in the most shallow part of the folder */\n\tfiles: FileEntryMeta[]\n\t/** the folders included only in the most shallow part of the folder */\n\tfolders: FolderEntryMeta[]\n\t/** when the folder was created (if not created now) in `ms` */\n\tcreated: number\n\t/** when the folder was changed (if not modified now) in `ms` */\n\tmodified: number\n\n\t/**\n\t * create metadata for a folder\n\t *\n\t * @param name - a nickname shown on the folder when accessed without adding to account metadata\n\t * @param files - the files included only in the most shallow part of the folder\n\t * @param created - when the folder was created (if not created now) in `ms`\n\t * @param created - when the folder was changed (if not modified now) in `ms`\n\t */\n\tconstructor ({\n\t\tname = \"Folder\",\n\t\tfiles = [],\n\t\tfolders = [],\n\t\tcreated = Date.now(),\n\t\tmodified = Date.now()\n\t}: {\n\t\tname?: string\n\t\tfiles?: FileEntryMeta[]\n\t\tfolders?: FolderEntryMeta[]\n\t\tcreated?: number\n\t\tmodified?: number\n\t} = {}) {\n\t\tthis.name = name\n\t\tthis.files = files\n\t\tthis.folders = folders\n\t\tthis.created = created\n\t\tthis.modified = modified\n\t}\n\n\t/** @internal */\n\tminify = () => new MinifiedFolderMeta([\n\t\tthis.name,\n\t\tthis.files.map(file => new FileEntryMeta(file).minify()),\n\t\tthis.folders.map(folder => new FolderEntryMeta(folder).minify()),\n\t\tthis.created,\n\t\tthis.modified\n\t])\n}\n\ntype MinifiedFolderMetaProps = [\n\tstring,\n\tMinifiedFileEntryMeta[],\n\tMinifiedFolderEntryMeta[],\n\tnumber,\n\tnumber\n]\n\n/**\n * @internal\n */\nclass MinifiedFolderMeta extends Array {\n\t/** a nickname shown on the folder when accessed without adding to account metadata */\n\t0: string\n\t/** the files included only in the most shallow part of the folder */\n\t1: MinifiedFileEntryMeta[]\n\t/** the folders included only in the most shallow part of the folder */\n\t2: MinifiedFolderEntryMeta[]\n\t/** when the folder was created (if not created now) in `ms` */\n\t3: number\n\t/** when the folder was changed (if not modified now) in `ms` */\n\t4: number\n\n\tconstructor ([\n\t\tname,\n\t\tfiles,\n\t\tfolders,\n\t\tcreated,\n\t\tmodified\n\t]: MinifiedFolderMetaProps) {\n\t\tsuper(5)\n\n\t\tthis[0] = name\n\t\tthis[1] = files\n\t\tthis[2] = folders\n\t\tthis[3] = created\n\t\tthis[4] = modified\n\t}\n\n\tunminify = () => new FolderMeta({\n\t\tname: this[0],\n\t\tfiles: this[1].map(file => new MinifiedFileEntryMeta(file as MinifiedFileEntryMetaProps).unminify()),\n\t\tfolders: this[2].map(folder => new MinifiedFolderEntryMeta(folder as MinifiedFolderEntryMetaProps).unminify()),\n\t\tcreated: this[3],\n\t\tmodified: this[4]\n\t})\n}\n\nexport { FolderMeta, MinifiedFolderMeta, MinifiedFolderMetaProps }\n","import { downloadFile } from \"../v0/downloadFile\";\nimport { generateSubHDKey } from \"../v0/generateSubHDKey\";\nimport { getAccountInfo } from \"../v0/getAccountInfo\";\nimport { getFolderHDKey } from \"../v0/getFolderHDKey\";\nimport { getFolderLocation } from \"../v0/getFolderLocation\";\nimport { getFolderMeta } from \"../v0/getFolderMeta\";\nimport { getHandle } from \"../v0/getHandle\";\nimport { isPaid } from \"../v0/isPaid\";\nimport { register } from \"../v0/register\";\n\nexport {\n\tdownloadFile,\n\tgenerateSubHDKey,\n\tgetAccountInfo,\n\tgetFolderHDKey,\n\tgetFolderLocation,\n\tgetFolderMeta,\n\tgetHandle,\n\tisPaid,\n\tregister\n}\n\n/**\n * internal API v0\n *\n * @internal\n */\nconst v0 = {\n\tdownloadFile,\n\tgenerateSubHDKey,\n\tgetAccountInfo,\n\tgetFolderHDKey,\n\tgetFolderLocation,\n\tgetFolderMeta,\n\tgetHandle,\n\tisPaid,\n\tregister\n}\n\nexport default v0\n","import { FileVersion, MinifiedFileVersion, MinifiedFileVersionProps } from \"./file-version\"\n\n/**\n * metadata to describe a file as it relates to the UI\n *\n * @public\n */\nclass FileEntryMeta {\n\t/** the name of the file as shown in the UI */\n\tname: string\n\t/** the date in `ms` that this file was initially uploaded */\n\tcreated: number\n\t/** the date in `ms` that the newest version of this file was uploaded */\n\tmodified: number\n\t/** versions of the uploaded file (the most recent of which should be the current version of the file) */\n\tversions: FileVersion[]\n\n\t/**\n\t * create metadata for a file entry in the UI\n\t *\n\t * @param name - the name of the file as shown in the UI\n\t * @param created - the date in `ms` that this file was initially uploaded\n\t * @param created - the date in `ms` that the newest version of this file was uploaded\n\t * @param versions - versions of the uploaded file (the most recent of which should be the current version of the file)\n\t */\n\tconstructor ({\n\t\tname,\n\t\tcreated = Date.now(),\n\t\tmodified = Date.now(),\n\t\tversions = []\n\t}: {\n\t\tname: string\n\t\tcreated?: number\n\t\tmodified?: number\n\t\tversions?: FileVersion[]\n\t}) {\n\t\tthis.name = name\n\t\tthis.created = created\n\t\tthis.modified = modified\n\t\tthis.versions = versions\n\t}\n\n\t/** @internal */\n\tminify = () => new MinifiedFileEntryMeta([\n\t\tthis.name,\n\t\tthis.created,\n\t\tthis.modified,\n\t\tthis.versions.map(version => new FileVersion(version).minify())\n\t])\n}\n\ntype MinifiedFileEntryMetaProps = [\n\tstring,\n\tnumber,\n\tnumber,\n\tMinifiedFileVersion[]\n]\n\n/**\n * @internal\n */\nclass MinifiedFileEntryMeta extends Array {\n\t/** the name of the file as shown in the UI */\n\t0: string\n\t/** the date in `ms` that this file was initially uploaded */\n\t1: number\n\t/** the date in `ms` that the newest version of this file was uploaded */\n\t2: number\n\t/** versions of the uploaded file (the most recent of which should be the current version of the file) */\n\t3: MinifiedFileVersion[]\n\n\tconstructor ([\n\t\tname,\n\t\tcreated,\n\t\tmodified,\n\t\tversions\n\t]: MinifiedFileEntryMetaProps) {\n\t\tsuper(4)\n\n\t\tthis[0] = name\n\t\tthis[1] = created\n\t\tthis[2] = modified\n\t\tthis[3] = versions\n\t}\n\n\tunminify = () => new FileEntryMeta({\n\t\tname: this[0],\n\t\tcreated: this[1],\n\t\tmodified: this[2],\n\t\tversions: this[3].map(version => new MinifiedFileVersion(version as unknown as MinifiedFileVersionProps).unminify())\n\t})\n}\n\nexport { FileEntryMeta, MinifiedFileEntryMeta, MinifiedFileEntryMetaProps }\n","/**\n * metadata to describe where a folder can be found (for root metadata of an account)\n *\n * @public\n */\nclass FolderEntryMeta {\n\t/** a name of the folder shown in the UI */\n\tname: string\n\t/**\n\t * the public key for the metadata file\n\t * it is how the file will be queried for (using the same system as for the account metadata)\n\t */\n\tlocation: string\n\n\t/**\n\t * create metadata entry for a folder\n\t *\n\t * @param name - a name of the folder shown in the UI\n\t * @param location - the public key for the metadata file\n\t *   it is how the file will be queried for (using the same system as for the account metadata)\n\t */\n\tconstructor ({\n\t\tname,\n\t\tlocation\n\t}: {\n\t\tname: string\n\t\tlocation: string\n\t}) {\n\t\tthis.name = name\n\t\tthis.location = location\n\t}\n\n\t/** @internal */\n\tminify = () => new MinifiedFolderEntryMeta([\n\t\tthis.name,\n\t\tthis.location\n\t])\n}\n\ntype MinifiedFolderEntryMetaProps = [\n\tstring,\n\tstring\n]\n\n/**\n * @internal\n */\nclass MinifiedFolderEntryMeta extends Array {\n\t/** a name of the folder shown in the UI */\n\t0: string\n\t/**\n\t * the public key for the metadata file\n\t * it is how the file will be queried for (using the same system as for the account metadata)\n\t */\n\t1: string\n\n\tconstructor ([\n\t\tname,\n\t\tlocation\n\t]: MinifiedFolderEntryMetaProps) {\n\t\tsuper(2)\n\n\t\tthis[0] = name\n\t\tthis[1] = location\n\t}\n\n\tunminify = () => new FolderEntryMeta({\n\t\tname: this[0],\n\t\tlocation: this[1]\n\t})\n}\n\nexport { FolderEntryMeta, MinifiedFolderEntryMeta, MinifiedFolderEntryMetaProps }\n","import Axios from \"axios\";\nimport HDKey from \"hdkey\";\n\nimport { getPayload } from \"../request\";\n\n/**\n * check the status of upgrading an account\n *\n * @param endpoint - the base url to send the request to\n * @param hdNode - the account to create\n * @param metadataKeys - all metadata keys from the account to upgrade\n * @param fileHandles - all file handles from the account to upgrade\n * @param duration - account duration in months\n * @param limit - storage limit in GB\n *\n * @internal\n */\nexport async function upgradeAccountStatus(endpoint: string, hdNode: HDKey, metadataKeys: string[], fileHandles: string[], duration = 12, limit = 128) {\n\tconst payload = {\n\t\tmetadataKeys,\n\t\tfileHandles,\n\t\tdurationInMonths: duration,\n\t\tstorageLimit: limit\n\t}\n\n\tconst signedPayload = getPayload(payload, hdNode);\n\n\treturn Axios.post(endpoint + \"/api/v1/upgrade\", signedPayload);\n}\n\n/**\n * request an invoice for upgrading an account\n *\n * @param endpoint - the base url to send the request to\n * @param hdNode - the account to create\n * @param duration - account duration in months\n * @param limit - storage limit in GB\n *\n * @internal\n */\nexport async function upgradeAccountInvoice(endpoint: string, hdNode: HDKey, duration = 12, limit = 128) {\n\tconst payload = {\n\t\tdurationInMonths: duration,\n\t\tstorageLimit: limit\n\t}\n\n\tconst signedPayload = getPayload(payload, hdNode);\n\n\treturn Axios.post(endpoint + \"/api/v1/upgrade/invoice\", signedPayload);\n}\n","import Axios from \"axios\";\nimport HDKey from \"hdkey\";\n\nimport { getPayload } from \"../request\";\n\n/**\n * check the status of renewing an account\n *\n * @param endpoint - the base url to send the request to\n * @param hdNode - the account to create\n * @param metadataKeys - all metadata keys from the account to renew\n * @param fileHandles - all file handles from the account to renew\n * @param duration - account duration in months\n * @param limit - storage limit in GB\n *\n * @internal\n */\nexport async function renewAccountStatus(endpoint: string, hdNode: HDKey, metadataKeys: string[], fileHandles: string[], duration = 12) {\n\tconst payload = {\n\t\tmetadataKeys,\n\t\tfileHandles,\n\t\tdurationInMonths: duration\n\t}\n\n\tconst signedPayload = getPayload(payload, hdNode);\n\n\treturn Axios.post(endpoint + \"/api/v1/renew\", signedPayload);\n}\n\n/**\n * request an invoice for renewing an account\n *\n * @param endpoint - the base url to send the request to\n * @param hdNode - the account to create\n * @param duration - account duration in months\n * @param limit - storage limit in GB\n *\n * @internal\n */\nexport async function renewAccountInvoice(endpoint: string, hdNode: HDKey, duration = 12) {\n\tconst payload = {\n\t\tdurationInMonths: duration\n\t}\n\n\tconst signedPayload = getPayload(payload, hdNode);\n\n\treturn Axios.post(endpoint + \"/api/v1/renew/invoice\", signedPayload);\n}\n","import Axios from \"axios\";\nimport { EventEmitter } from \"events\";\nimport { createMetadata, encryptMetadata, FileMeta, FileMetaOptions } from \"./core/metadata\";\nimport {\n  generateFileKeys,\n  getUploadSize,\n  getFileData,\n  getEndIndex,\n  FileData\n} from \"./core/helpers\";\nimport FormDataNode from \"form-data\";\nimport EncryptStream from \"./streams/encryptStream\";\nimport UploadStream from \"./streams/uploadStream\";\nimport { Readable } from \"readable-stream\";\nimport { getPayloadFD } from \"./core/request\";\nimport HDKey from \"hdkey\";\n\nconst PART_MIN_SIZE = 1024 * 1024 * 5;\nconst POLYFILL_FORMDATA = typeof FormData === \"undefined\";\n\ntype UploadOptions = {\n  autoStart?: boolean,\n  endpoint?: boolean,\n  params?: FileMetaOptions\n}\nconst DEFAULT_OPTIONS: UploadOptions = Object.freeze({\n  autoStart: true\n});\nconst DEFAULT_FILE_PARAMS = {\n  blockSize: 64 * 1024, // 64 KiB encryption blocks\n}\n\n/**\n * @internal\n */\nexport default class Upload extends EventEmitter {\n  account: HDKey\n  options: UploadOptions\n  data: FileData\n  uploadSize\n  key: string\n  hash: string\n  handle: string\n  metadata: FileMeta\n  readStream: Readable\n  encryptStream: EncryptStream\n  uploadStream: UploadStream\n\n  constructor(file, account, opts: UploadOptions = {}) {\n    super();\n\n    const options = Object.assign({}, DEFAULT_OPTIONS, opts);\n    options.params = Object.assign({}, DEFAULT_FILE_PARAMS, options.params || {});\n\n    const { handle, hash, key } = generateFileKeys();\n    const data = getFileData(file, handle);\n    const size = getUploadSize(data.size, options.params);\n\n    this.account = account;\n    this.options = options;\n    this.data = data;\n    this.uploadSize = size;\n    this.key = key; // Encryption key\n    this.hash = hash; // Datamap entry hash\n    this.handle = handle; // File handle - hex(hash) + hex(key)\n    this.metadata = createMetadata(data, options.params);\n\n    if (options.autoStart) {\n      this.startUpload()\n    }\n  }\n\n  startUpload = async () => {\n    try {\n      await this.uploadMetadata();\n      await this.uploadFile();\n    } catch(e) {\n      this.propagateError(e);\n    }\n  }\n\n  uploadMetadata = async () => {\n    const meta = createMetadata(this.data, this.options.params);\n    const encryptedMeta = encryptMetadata(meta, this.key);\n    const data = getPayloadFD({\n      fileHandle: this.hash,\n      fileSizeInByte: this.uploadSize,\n      endIndex: getEndIndex(this.uploadSize, this.options.params)\n    }, {\n      metadata: encryptedMeta\n    }, this.account);\n\n    const url = this.options.endpoint + \"/api/v1/init-upload\";\n    const headers = (data as FormDataNode).getHeaders ? (data as FormDataNode).getHeaders() : {};\n    const req = Axios.post(url, data, { headers });\n    const res = await req;\n\n    this.emit(\"metadata\", meta);\n  }\n\n  uploadFile = async () => {\n    const readStream = new this.data.reader(this.data, this.options.params);\n\n    this.readStream = readStream;\n    this.encryptStream = new EncryptStream(this.key, this.options.params);\n    this.uploadStream = new UploadStream(this.account, this.hash, this.uploadSize, this.options.endpoint, this.options.params);\n\n    this.uploadStream.on(\"progress\", progress => {\n      this.emit(\"upload-progress\", {\n        target: this,\n        handle: this.handle,\n        progress\n      });\n    });\n\n    this.readStream\n      .pipe(this.encryptStream)\n      .pipe(this.uploadStream)\n      .on(\"finish\", this.finishUpload);\n\n    this.readStream.on(\"error\", this.propagateError);\n    this.encryptStream.on(\"error\", this.propagateError);\n    this.uploadStream.on(\"error\", this.propagateError);\n  }\n\n  finishUpload = async () => {\n    this.emit(\"finish\", {\n      target: this,\n      handle: this.handle,\n      metadata: this.metadata\n    });\n  }\n\n  propagateError = (error) => {\n    process.nextTick(() => this.emit(\"error\", error));\n  }\n}\n","/**\n * metadata to describe a version of a file as it relates to a filesystem\n *\n * @public\n */\nclass FileVersion {\n\t/** the shareable handle of the file */\n\thandle: string\n\t/** the size of the file in bytes */\n\tsize: number\n\t/** the date in `ms` that this version was uploaded */\n\tcreated: number\n\t/** the date in `ms` that the filesystem marked as last modified */\n\tmodified: number\n\n\t/**\n\t * create metadata for a file version\n\t *\n\t * @param handle - the file handle\n\t * @param size - the size of the file in bytes\n\t * @param created - the date this version was uploaded\n\t * @param modified - the date the filesystem marked as last modified\n\t */\n\tconstructor ({\n\t\thandle,\n\t\tsize,\n\t\tcreated = Date.now(),\n\t\tmodified = Date.now()\n\t}: {\n\t\thandle: string\n\t\tsize: number\n\t\tcreated?: number\n\t\tmodified?: number\n\t}) {\n\t\tthis.handle = handle\n\t\tthis.size = size\n\t\tthis.created = created\n\t\tthis.modified = modified\n\t}\n\n\t/** @internal */\n\tminify = () => new MinifiedFileVersion([\n\t\tthis.handle,\n\t\tthis.size,\n\t\tthis.created,\n\t\tthis.modified\n\t])\n}\n\ntype MinifiedFileVersionProps = [\n\t/** the shareable handle of the file */\n\tstring,\n\t/** the size of the file in bytes */\n\tnumber,\n\t/** the date in `ms` that this version was uploaded */\n\tnumber,\n\t/** the date in `ms` that the filesystem marked as last modified */\n\tnumber\n]\n\n/**\n * @internal\n */\nclass MinifiedFileVersion extends Array {\n\tconstructor ([\n\t\thandle,\n\t\tsize,\n\t\tcreated,\n\t\tmodified\n\t]: MinifiedFileVersionProps) {\n\t\tsuper(4)\n\n\t\tthis[0] = handle\n\t\tthis[1] = size\n\t\tthis[2] = created\n\t\tthis[3] = modified\n\t}\n\n\tunminify = () => new FileVersion({\n\t\thandle: this[0],\n\t\tsize: this[1],\n\t\tcreated: this[2],\n\t\tmodified: this[3]\n\t})\n}\n\nexport { FileVersion, MinifiedFileVersion, MinifiedFileVersionProps }\n","import { sanitizeFilename, FileData } from \"./helpers\";\nimport { encryptString, decryptString } from \"./encryption\";\nimport { util as ForgeUtil } from \"node-forge\";\n\nconst Forge = { util: ForgeUtil };\n\nconst PROTOCOL_VERSION = 1;\n\nexport type FileMetaOptions = {\n  blockSize?: number\n  chunkSize?: number\n}\n\nexport type FileMeta = {\n  name: string\n  type: string\n  size: number\n  p: FileMetaOptions\n}\n\nexport function createMetadata (file: FileData, opts: FileMetaOptions) {\n  const filename = sanitizeFilename(file.name);\n\n  const metadata: FileMeta = {\n    name: filename,\n    type: file.type,\n    size: file.size,\n    p: opts\n  }\n\n  return metadata;\n}\n\nexport function encryptMetadata (metadata: FileMeta, key: string) {\n  const encryptedMeta = encryptString(key, JSON.stringify(metadata), \"utf8\");\n  return Forge.util.binary.raw.decode(encryptedMeta.getBytes());\n}\n\nexport function decryptMetadata (data: Uint8Array, key: string) {\n  const byteStr = Forge.util.binary.raw.encode(data);\n  const byteBuffer = new Forge.util.ByteBuffer(byteStr);\n  const meta: FileMeta = JSON.parse(decryptString(key, byteBuffer));\n\n  return meta;\n}\n","import { md as ForgeMd, random as ForgeRandom, util as ForgeUtil } from \"node-forge\"\nimport isBuffer from \"is-buffer\";\nimport FileSourceStream from \"../streams/fileSourceStream\";\nimport BufferSourceStream from \"../streams/bufferSourceStream\";\nimport { Readable } from \"readable-stream\";\nimport mime from \"mime/lite\";\nimport { FileMeta, FileMetaOptions } from \"./metadata\"\nimport {\n  FILENAME_MAX_LENGTH,\n  BLOCK_OVERHEAD,\n  DEFAULT_BLOCK_SIZE,\n  DEFAULT_PART_SIZE\n} from \"./constants\";\nimport { Buffer } from \"safe-buffer\";\n\nconst Forge = { md: ForgeMd, random: ForgeRandom, util: ForgeUtil };\nconst ByteBuffer = Forge.util.ByteBuffer;\n\n// Generate new handle, datamap entry hash and encryption key\n// TODO: Decide on format and derivation\nexport function generateFileKeys() {\n  const hash = Forge.md.sha256\n    .create()\n    .update(Forge.random.getBytesSync(32))\n    .digest().toHex();\n\n  const key = Forge.md.sha256\n    .create()\n    .update(Forge.random.getBytesSync(32))\n    .digest().toHex();\n\n  const handle = hash + key;\n\n  return {\n    hash,\n    key,\n    handle\n  }\n}\n\n// Return datamap hash and encryption key from handle\n// TODO: Decide on format and derivation\nexport function keysFromHandle(handle: string) {\n  const bytes = Forge.util.binary.hex.decode(handle);\n  const buf = new ByteBuffer(bytes);\n  const hash = buf.getBytes(32);\n  const key = buf.getBytes(32);\n\n  return {\n    hash: Forge.util.bytesToHex(hash),\n    key: Forge.util.bytesToHex(key),\n    handle\n  }\n}\n\nexport function sanitizeFilename(filename: string) {\n  if(filename.length > FILENAME_MAX_LENGTH) {\n    const l = (FILENAME_MAX_LENGTH / 2) - 2;\n    const start = filename.substring(0, l);\n    const end = filename.substring(filename.length - l);\n    filename = start + \"...\" + end;\n  }\n\n  return filename;\n}\n\nexport type FileData = {\n  data: Buffer\n  size: number\n  name: string\n  type: string\n  reader: typeof Readable | typeof BufferSourceStream | typeof FileSourceStream\n}\n\n// Rudimentary format normalization\nexport function getFileData(file: Buffer | FileData, nameFallback = \"file\"): FileData {\n  if (isBuffer(file)) {\n    file = file as Buffer\n    return {\n      data: file,\n      size: file.length,\n      name: nameFallback,\n      type: \"application/octet-stream\",\n      reader: BufferSourceStream\n    }\n  } else if(file && (file as FileData).data && isBuffer((file as FileData).data)) {\n    file = file as FileData\n    return {\n      data: file.data,\n      size: file.data.length,\n      name: file.name || nameFallback,\n      type: file.type || mime.getType(file.name) || \"\",\n      reader: BufferSourceStream\n    }\n  } else {\n    // TODO\n    (file as unknown as FileData).reader = FileSourceStream;\n  }\n\n  return file as FileData;\n}\n\nexport function getMimeType(metadata: FileMeta) {\n  return metadata.type || mime.getType(metadata.name) || \"\";\n}\n\n// get true upload size, accounting for encryption overhead\nexport function getUploadSize(size: number, params: FileMetaOptions) {\n  const blockSize = params.blockSize || DEFAULT_BLOCK_SIZE;\n  const blockCount = Math.ceil(size / blockSize);\n  return size + blockCount * BLOCK_OVERHEAD;\n}\n\n// get\nexport function getEndIndex(uploadSize, params) {\n  const blockSize = params.blockSize || DEFAULT_BLOCK_SIZE;\n  const partSize = params.partSize || DEFAULT_PART_SIZE;\n  const chunkSize = blockSize + BLOCK_OVERHEAD;\n  const chunkCount = Math.ceil(uploadSize / chunkSize);\n  const chunksPerPart = Math.ceil(partSize / chunkSize);\n  const endIndex = Math.ceil(chunkCount / chunksPerPart);\n\n  return endIndex;\n}\n\nexport function getBlockSize(params) {\n  if(params && params.blockSize) {\n    return params.blockSize;\n  } else if(params && params.p && params.p.blockSize) {\n    return params.p.blockSize;\n  } else {\n    return DEFAULT_BLOCK_SIZE;\n  }\n}\n","import { Transform } from \"readable-stream\";\nimport { decryptBytes } from \"../core/encryption\";\nimport { util as ForgeUtil } from \"node-forge\";\nimport {\n  DEFAULT_BLOCK_SIZE,\n  BLOCK_OVERHEAD\n} from \"../core/constants\";\nimport { getBlockSize } from \"../core/helpers\";\n\nconst Forge = { util: ForgeUtil };\nconst DEFAULT_OPTIONS = Object.freeze({\n  binaryMode: false,\n  objectMode: true,\n  blockSize: DEFAULT_BLOCK_SIZE\n});\n\nexport default class DecryptStream extends Transform {\n  options\n  blockSize\n  key\n  iter\n\n  constructor(key, options?) {\n    const opts = Object.assign({}, DEFAULT_OPTIONS, options);\n\n    super(opts);\n    this.options = opts;\n    this.key = key;\n    this.iter = 0;\n    this.blockSize = getBlockSize(options);\n  }\n\n  _transform(chunk, encoding, callback) {\n    const blockSize = this.blockSize;\n    const chunkSize = blockSize + BLOCK_OVERHEAD;\n    const length = chunk.length;\n\n    for(let offset = 0; offset < length; offset += chunkSize) {\n      const limit = Math.min(offset + chunkSize, length);\n      const buf = chunk.slice(offset, limit);\n      const data = decryptBytes(this.key, buf);\n\n      if(data) {\n        this.push(data);\n      } else {\n        this.emit(\"error\", \"Error decrypting data block\");\n      }\n    }\n\n    callback(null);\n  }\n}\n","import Axios from \"axios\";\nimport { Readable } from \"readable-stream\";\nimport { getBlockSize } from \"../core/helpers\";\nimport {\n  DEFAULT_BLOCK_SIZE,\n  BLOCK_OVERHEAD\n} from \"../core/constants\";\n\n\nconst DEFAULT_OPTIONS = Object.freeze({\n  autostart: true,\n  maxParallelDownloads: 1,\n  maxRetries: 0,\n  partSize: 80 * (DEFAULT_BLOCK_SIZE + BLOCK_OVERHEAD), // ~5 MiB data chunks\n  objectMode: false\n});\n\nexport default class DownloadStream extends Readable {\n  options\n  url\n  size\n  metadata\n\n  chunks\n  chunkId\n  pushId\n  bytesDownloaded\n  isDownloadFinished\n  ongoingDownloads\n  pushChunk\n\n  constructor(url, metadata, size, options = {}) {\n    const opts = Object.assign({}, DEFAULT_OPTIONS, options);\n    super(opts);\n\n    // Input\n    this.options = opts;\n    this.url = url;\n    this.size = size;\n    this.metadata = metadata;\n\n    // Internal\n    this.chunks = [];\n    this.chunkId = 0;\n    this.pushId = 0;\n    this.bytesDownloaded = 0;\n    this.isDownloadFinished = false;\n    this.ongoingDownloads = 0;\n    this.pushChunk = false;\n\n    const blockSize = getBlockSize(metadata);\n    const blockCount = opts.partSize / (blockSize + BLOCK_OVERHEAD);\n    if(blockCount !== Math.floor(blockCount)) {\n      this.emit(\"error\", \"options.partSize must be a multiple of blockSize + blockOverhead\");\n    }\n\n    if(opts.autostart) {\n      this._download();\n    }\n  }\n  _read() {\n    this.pushChunk = true;\n\n    const attemptDownload =\n      this.ongoingDownloads < this.options.maxParallelDownloads;\n    if (!this.isDownloadFinished && attemptDownload) {\n      this._download();\n    }\n\n    this._pushChunk();\n  }\n\n  async _download(chunkIndex?) {\n    const size = this.size;\n    const partSize = this.options.partSize;\n    const index = chunkIndex || this.chunks.length;\n    const offset = index * partSize;\n\n    // TODO: Make sure last byte works to prevent edge case\n    if (offset >= size) {\n      this.isDownloadFinished = true;\n      return;\n    }\n\n    const limit = Math.min(offset + partSize, size) - offset;\n    const range = `bytes=${offset}-${offset + limit - 1}`;\n    const chunk = {\n      id: this.chunkId++,\n      data: null,\n      offset,\n      limit\n    };\n\n    try {\n      this.chunks.push(chunk);\n      this.ongoingDownloads++;\n      const download = await Axios.get(this.url + \"/file\", {\n        responseType: \"arraybuffer\",\n        headers: {\n          range\n        }\n      });\n\n      chunk.data = new Uint8Array(download.data);\n      this.bytesDownloaded += chunk.data.length;\n      this.ongoingDownloads--;\n      this.emit(\"progress\", this.bytesDownloaded / this.size);\n      this._pushChunk();\n    } catch (error) {\n      this.ongoingDownloads--;\n      this.emit(\"error\", error);\n    }\n\n    return;\n  }\n\n  async _afterDownload() {\n\n  }\n\n  _pushChunk() {\n    if (!this.pushChunk) {\n      return;\n    }\n\n    const chunk = this.chunks[this.pushId];\n    if (chunk && chunk.data !== null) {\n      this.pushId++;\n      this.pushChunk = this.push(chunk.data);\n      chunk.data = null;\n      this._pushChunk();\n    } else if(this.ongoingDownloads === 0 && this.isDownloadFinished) {\n      this.push(null);\n    }\n  }\n}\n","import FormDataNode from \"form-data\";\nimport * as EthUtil from \"ethereumjs-util\";\nimport HDKey from \"hdkey\"\n\nconst POLYFILL_FORMDATA = typeof FormData === \"undefined\";\n\n/**\n * get a signed payload from an hdkey\n *\n * @param rawPayload - a payload object to be processed and signed\n * @param hdNode = the account to sign with\n * @param key\n *\n * @internal\n */\nexport function getPayload(rawPayload, hdNode: HDKey, key = \"requestBody\") {\n  const payload = JSON.stringify(rawPayload);\n  const hash = EthUtil.keccak256(payload);\n  const signature = hdNode.sign(hash).toString(\"hex\");\n  const pubKey = hdNode.publicKey.toString(\"hex\");\n  const signedPayload = {\n    signature,\n    publicKey: pubKey,\n    hash: hash.toString(\"hex\")\n  }\n\n  signedPayload[key] = payload;\n\n  return signedPayload;\n}\n\n/**\n * get a signed formdata payload from an hdkey\n *\n * @param rawPayload - a payload object to be processed and signed\n * @param extraPayload - additional (unsigned) payload information\n * @param hdNode - the account to sign with\n * @param key\n *\n * @internal\n */\nexport function getPayloadFD(rawPayload: { [key: string]: any }, extraPayload, hdNode: HDKey, key = \"requestBody\") {\n  // rawPayload.timestamp = Date.now();\n\n  const payload = JSON.stringify(rawPayload);\n  const hash = EthUtil.keccak256(payload);\n  const signature = hdNode.sign(hash).toString(\"hex\");\n  const pubKey = hdNode.publicKey.toString(\"hex\");\n\n  // node, buffers\n  if(POLYFILL_FORMDATA) {\n    const data = new FormDataNode();\n\n    data.append(key, payload);\n    data.append(\"signature\", signature);\n    data.append(\"publicKey\", pubKey);\n    // data.append(\"hash\", hash);\n\n    if(extraPayload) {\n      Object.keys(extraPayload).forEach(key => {\n        const pl = Buffer.from(extraPayload[key]);\n\n        data.append(key, pl, {\n          filename: key,\n          contentType: \"application/octet-stream\",\n          knownLength: pl.length\n        });\n      });\n    }\n\n    return data;\n  } else {\n    const data = new FormData();\n\n    data.append(key, payload);\n    data.append(\"signature\", signature);\n    data.append(\"publicKey\", pubKey);\n\n    if(extraPayload) {\n      Object.keys(extraPayload).forEach(key => {\n        data.append(key, new Blob([extraPayload[key].buffer]), key);\n      });\n    }\n\n    return data;\n  }\n}\n\nexport { getPlans } from \"./requests/getPlans\";\nexport { checkPaymentStatus } from \"./requests/checkPaymentStatus\";\nexport { createAccount } from \"./requests/createAccount\";\nexport { getMetadata, setMetadata, createMetadata, deleteMetadata } from \"./requests/metadata\";\n","export const FILENAME_MAX_LENGTH = 256;\nexport const CURRENT_VERSION = 1;\nexport const IV_BYTE_LENGTH = 16;\nexport const TAG_BYTE_LENGTH = 16;\nexport const TAG_BIT_LENGTH = TAG_BYTE_LENGTH * 8;\nexport const DEFAULT_BLOCK_SIZE = 64 * 1024;\nexport const BLOCK_OVERHEAD = TAG_BYTE_LENGTH + IV_BYTE_LENGTH;\nexport const DEFAULT_PART_SIZE = 128 * (DEFAULT_BLOCK_SIZE + BLOCK_OVERHEAD);\n","import { util as ForgeUtil } from \"node-forge\";\n\nimport { hash } from \"../../../../core/hashing\";\nimport { getMetadata } from \"../../../../core/requests/metadata\";\nimport { decrypt } from \"../../../../core/encryption\";\n\nimport { MasterHandle } from \"../../../../account\";\nimport {\n\tFolderMeta,\n\tMinifiedFolderMeta\n} from \"../../../../core/account/folder-meta\";\n\nimport { cleanPath } from \"../../../../utils/cleanPath\";\n\nconst getFolderMeta = async (masterHandle: MasterHandle, dir: string): Promise<FolderMeta> => {\n\tdir = cleanPath(dir)\n\n\tconst\n\t\tfolderKey = masterHandle.getFolderHDKey(dir),\n\t\tlocation = masterHandle.getFolderLocation(dir),\n\t\tkey = hash(folderKey.privateKey.toString(\"hex\")),\n\t\t// TODO: verify folder can only be read by the creating account\n\t\tresponse = await getMetadata(\n\t\t\tmasterHandle.uploadOpts.endpoint,\n\t\t\tmasterHandle,\n\t\t\t// folderKey,\n\t\t\tlocation\n\t\t)\n\n\ttry {\n\t\t// TODO\n\t\t// I have no idea why but the decrypted is correct hex without converting\n\t\tconst metaString = (\n\t\t\tdecrypt(\n\t\t\t\tkey,\n\t\t\t\tnew ForgeUtil.ByteBuffer(Buffer.from(response.data.metadata, \"hex\"))\n\t\t\t) as ForgeUtil.ByteBuffer\n\t\t).toString();\n\n\t\ttry {\n\t\t\tconst meta = JSON.parse(metaString)\n\n\t\t\treturn meta\n\t\t} catch (err) {\n\t\t\tconsole.error(err)\n\n\t\t\tconsole.info(\"META STRING:\", metaString)\n\n\t\t\tthrow new Error(\"metadata corrupted\")\n\t\t}\n\t} catch (err) {\n\t\tconsole.error(err)\n\n\t\tthrow new Error(\"error decrypting meta\")\n\t}\n}\n\nexport { getFolderMeta }\n","import { Transform } from \"readable-stream\";\nimport { encryptBytes } from \"../core/encryption\";\nimport { util as ForgeUtil } from \"node-forge\";\n\nconst Forge = { util: ForgeUtil };\nconst DEFAULT_OPTIONS = Object.freeze({\n  objectMode: false\n});\n\nexport default class EncryptStream extends Transform {\n  options\n  key\n\n  constructor(key, options) {\n    const opts = Object.assign({}, DEFAULT_OPTIONS, options);\n\n    super(opts);\n    this.options = opts;\n    this.key = key;\n  }\n  _transform(data, encoding, callback) {\n    const chunk = encryptBytes(this.key, data);\n    const buf = Forge.util.binary.raw.decode(chunk.getBytes());\n\n    this.push(buf);\n    callback(null);\n  }\n}\n","import Axios from \"axios\";\nimport FormDataNode from \"form-data\";\nimport { Writable } from \"readable-stream\";\nimport { getPayload, getPayloadFD } from \"../core/request\";\nimport { getEndIndex } from \"../core/helpers\";\nimport { DEFAULT_PART_SIZE } from \"../core/constants\";\n\nconst POLYFILL_FORMDATA = typeof FormData === \"undefined\";\nconst PART_MIME = \"application/octet-stream\";\nconst DEFAULT_OPTIONS = Object.freeze({\n  maxParallelUploads: 3,\n  maxRetries: 0,\n  partSize: DEFAULT_PART_SIZE,\n  objectMode: false\n});\n\nexport default class UploadStream extends Writable {\n  account: any\n  hash: Buffer\n  endpoint: any\n  options: any\n  size: number\n  endIndex: number\n\n  private bytesUploaded: number\n  private blockBuffer: any[]\n  private partBuffer: any[]\n  private bufferSize: number\n  private ongoingUploads: number\n  private retries: number\n  private partIndex: number\n  private finalCallback: Function\n\n  constructor(account, hash, size, endpoint, options) {\n    const opts = Object.assign({}, DEFAULT_OPTIONS, options);\n\n    super(opts);\n\n    // Input\n    this.account = account;\n    this.hash = hash;\n    this.endpoint = endpoint;\n    this.options = opts;\n    this.size = size;\n    this.endIndex = getEndIndex(size, opts);\n\n    // Internal\n    this.bytesUploaded = 0;\n    this.blockBuffer = [];\n    this.partBuffer = [];\n    this.bufferSize = 0;\n    this.ongoingUploads = 0;\n    this.retries = 0;\n    this.partIndex = 0;\n    this.finalCallback = null;\n  }\n\n  _write(data, encoding, callback) {\n    this.blockBuffer.push(data);\n    this.bufferSize += data.length;\n\n    if (this.bufferSize >= this.options.partSize) {\n      this._addPart();\n      this._attemptUpload();\n    }\n\n    callback();\n  }\n\n  _final(callback) {\n    this.finalCallback = callback;\n\n    if (this.blockBuffer.length > 0) {\n      this._addPart();\n      this._attemptUpload();\n    } else if (this.ongoingUploads === 0) {\n      this._finishUpload();\n    }\n  }\n\n  // Flatten inputs into a single ArrayBuffer for sending\n  _addPart() {\n    const blocks = this.blockBuffer;\n    const data = new Uint8Array(this.bufferSize);\n    let offset = 0;\n\n    do {\n      const block = blocks.shift();\n      data.set(block, offset);\n      offset += block.length;\n    } while(blocks.length > 0);\n\n    this.partBuffer.push({\n      partIndex: ++this.partIndex,\n      data\n    });\n\n    this.blockBuffer = [];\n    this.bufferSize = 0;\n  }\n\n  _attemptUpload() {\n    if (this.ongoingUploads >= this.options.maxParallelUploads) {\n      return;\n    }\n\n    const part = this.partBuffer.shift();\n    this._upload(part);\n  }\n\n  _upload(part) {\n    this.ongoingUploads++;\n\n    // Cork stream when busy\n    if (this.ongoingUploads === this.options.maxParallelUploads) {\n      this.cork();\n    }\n\n    const data = getPayloadFD({\n      fileHandle: this.hash,\n      partIndex: part.partIndex,\n      endIndex: this.endIndex\n    }, {\n      chunkData: part.data\n    }, this.account);\n\n    const upload = Axios.post(this.endpoint + \"/api/v1/upload\", data, {\n      headers: (data as FormDataNode).getHeaders ? (data as FormDataNode).getHeaders() : {},\n      onUploadProgress: (event) => {\n        return\n      }\n    })\n    .then(result => {\n      this._afterUpload(part);\n    })\n    .catch(error => {\n      this._uploadError(error, part);\n    });\n  }\n\n  _afterUpload(part) {\n    this.ongoingUploads--;\n    this.bytesUploaded += part.data.length;\n\n    this.emit(\"progress\", this.bytesUploaded / this.size);\n\n    // Upload until done\n    if (this.partBuffer.length > 0) {\n      return this._attemptUpload();\n    }\n\n    if (this.finalCallback) {\n      // Finish\n      if (this.ongoingUploads === 0) {\n        this._finishUpload();\n      }\n    } else {\n      // Continue\n      process.nextTick(() => this.uncork());\n    }\n  }\n\n  async _finishUpload () {\n    const confirmUpload = this._confirmUpload.bind(this);\n    const data = getPayload({\n      fileHandle: this.hash\n    }, this.account);\n\n    let uploadFinished = false;\n\n    do {\n      uploadFinished = await confirmUpload(data);\n\n      if(!uploadFinished) {\n        await new Promise(resolve => setTimeout(resolve, 5000));\n      }\n    } while(!uploadFinished);\n\n    this.finalCallback();\n  }\n\n  async _confirmUpload (data) {\n    try {\n      const req = Axios.post(this.endpoint + \"/api/v1/upload-status\", data)\n      const res: {\n        data: {\n          status: string,\n          missingIndexes?: number[],\n          endIndex: number\n        }\n      } = await req as unknown as any\n\n      if (!res.data.missingIndexes || !res.data.missingIndexes.length) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch(err) {\n      console.warn(err.message || err);\n      return false;\n    }\n  }\n\n  _uploadError(error, part) {\n    this.ongoingUploads--;\n\n    console.warn(\"error\", error);\n\n    if (this.retries++ < this.options.maxRetries) {\n      console.log(\"retrying\", this.retries, \"of\", this.options.maxRetries);\n      this.partBuffer.push(part);\n      this._attemptUpload();\n      return;\n    }\n\n    if (this.finalCallback) {\n      this.finalCallback(error);\n    } else {\n      this.emit(\"error\", error);\n      this.end();\n    }\n  }\n}\n","import { Readable } from \"readable-stream\";\n\nconst DEFAULT_OPTIONS = Object.freeze({\n  objectMode: false\n});\n\nexport default class FileSourceStream extends Readable {\n  offset\n  options\n  blob\n  reader\n\n  constructor(blob, options) {\n    const opts = Object.assign({}, DEFAULT_OPTIONS, options);\n\n    console.log(\"Starting file source stream\", blob);\n\n    super(opts);\n    this.offset = 0;\n    this.options = opts;\n    this.blob = blob;\n    this.reader = new FileReader();\n    this._onChunkRead = this._onChunkRead.bind(this);\n\n    if(opts.blockSize <= 0) {\n      throw new Error(`Invalid blockSize '${opts.blockSize}' in source stream.`);\n    }\n  }\n\n  _read() {\n    if(this.reader.readyState !== FileReader.LOADING) {\n      this._readChunkFromBlob();\n    }\n  }\n\n  _readChunkFromBlob() {\n    const blob = this.blob;\n    const offset = this.offset;\n    const blockSize = this.options.blockSize;\n    const limit = Math.min(offset + blockSize, blob.size);\n\n    // End stream when file is read in\n    if (offset >= blob.size) {\n      return this.push(null);\n    }\n\n    const chunk = blob.slice(offset, limit, \"application/octet-stream\");\n\n    this.offset += blockSize;\n    this.reader.onload = this._onChunkRead;\n    this.reader.readAsArrayBuffer(chunk);\n  }\n\n  _onChunkRead(event) {\n    const chunk = event.target.result;\n\n    if(this.push(new Uint8Array(chunk))) {\n      this._read();\n    }\n  }\n}\n","import { Readable } from \"readable-stream\";\n\nconst DEFAULT_OPTIONS = Object.freeze({\n  objectMode: false\n});\n\nexport default class BufferSourceStream extends Readable {\n  offset\n  options\n  buffer\n\n  constructor(data, options) {\n    const opts = Object.assign({}, DEFAULT_OPTIONS, options);\n\n    super(opts);\n    this.offset = 0;\n    this.options = opts;\n    this.buffer = data.data;\n\n    if(opts.blockSize <= 0) {\n      throw new Error(`Invalid blockSize '${opts.blockSize}' in source stream.`);\n    }\n  }\n\n  _read() {\n    let read;\n\n    do {\n      read = this.push(this._readChunkFromBuffer());\n    } while(read);\n  }\n\n  _readChunkFromBuffer() {\n    const buf = this.buffer;\n    const offset = this.offset;\n    const blockSize = this.options.blockSize;\n    const limit = Math.min(offset + blockSize, buf.length) - offset;\n\n    // End stream when file is read in\n    if (offset >= buf.length) {\n      return null;\n    }\n\n    const slice = buf.slice(offset, offset + limit);\n\n    this.offset += blockSize;\n    return slice;\n  }\n}\n","import Axios from \"axios\";\n\n/**\n * get a list of available plans\n *\n * @param endpoint\n *\n * @internal\n */\nexport async function getPlans(endpoint: string) {\n  return Axios.get(endpoint + \"/plans\");\n}\n"]}